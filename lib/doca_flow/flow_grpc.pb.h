// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flow_grpc.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flow_5fgrpc_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flow_5fgrpc_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flow_5fgrpc_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flow_5fgrpc_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[19]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flow_5fgrpc_2eproto;
namespace flow_grpc {
class APPPortConfig;
struct APPPortConfigDefaultTypeInternal;
extern APPPortConfigDefaultTypeInternal _APPPortConfig_default_instance_;
class Action;
struct ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class AddEntryRequest;
struct AddEntryRequestDefaultTypeInternal;
extern AddEntryRequestDefaultTypeInternal _AddEntryRequest_default_instance_;
class CreatePipeRequest;
struct CreatePipeRequestDefaultTypeInternal;
extern CreatePipeRequestDefaultTypeInternal _CreatePipeRequest_default_instance_;
class DPDKConfig;
struct DPDKConfigDefaultTypeInternal;
extern DPDKConfigDefaultTypeInternal _DPDKConfig_default_instance_;
class DestroyPipeRequest;
struct DestroyPipeRequestDefaultTypeInternal;
extern DestroyPipeRequestDefaultTypeInternal _DestroyPipeRequest_default_instance_;
class EnvDestroyRequest;
struct EnvDestroyRequestDefaultTypeInternal;
extern EnvDestroyRequestDefaultTypeInternal _EnvDestroyRequest_default_instance_;
class Error;
struct ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class FWD;
struct FWDDefaultTypeInternal;
extern FWDDefaultTypeInternal _FWD_default_instance_;
class FlowPortConfig;
struct FlowPortConfigDefaultTypeInternal;
extern FlowPortConfigDefaultTypeInternal _FlowPortConfig_default_instance_;
class GRPCConfig;
struct GRPCConfigDefaultTypeInternal;
extern GRPCConfigDefaultTypeInternal _GRPCConfig_default_instance_;
class Match;
struct MatchDefaultTypeInternal;
extern MatchDefaultTypeInternal _Match_default_instance_;
class PipeConfig;
struct PipeConfigDefaultTypeInternal;
extern PipeConfigDefaultTypeInternal _PipeConfig_default_instance_;
class PortDumpRequest;
struct PortDumpRequestDefaultTypeInternal;
extern PortDumpRequestDefaultTypeInternal _PortDumpRequest_default_instance_;
class PortFlushRequest;
struct PortFlushRequestDefaultTypeInternal;
extern PortFlushRequestDefaultTypeInternal _PortFlushRequest_default_instance_;
class PortPairRequest;
struct PortPairRequestDefaultTypeInternal;
extern PortPairRequestDefaultTypeInternal _PortPairRequest_default_instance_;
class QueryRequest;
struct QueryRequestDefaultTypeInternal;
extern QueryRequestDefaultTypeInternal _QueryRequest_default_instance_;
class Response;
struct ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RmEntryRequest;
struct RmEntryRequestDefaultTypeInternal;
extern RmEntryRequestDefaultTypeInternal _RmEntryRequest_default_instance_;
}  // namespace flow_grpc
PROTOBUF_NAMESPACE_OPEN
template<> ::flow_grpc::APPPortConfig* Arena::CreateMaybeMessage<::flow_grpc::APPPortConfig>(Arena*);
template<> ::flow_grpc::Action* Arena::CreateMaybeMessage<::flow_grpc::Action>(Arena*);
template<> ::flow_grpc::AddEntryRequest* Arena::CreateMaybeMessage<::flow_grpc::AddEntryRequest>(Arena*);
template<> ::flow_grpc::CreatePipeRequest* Arena::CreateMaybeMessage<::flow_grpc::CreatePipeRequest>(Arena*);
template<> ::flow_grpc::DPDKConfig* Arena::CreateMaybeMessage<::flow_grpc::DPDKConfig>(Arena*);
template<> ::flow_grpc::DestroyPipeRequest* Arena::CreateMaybeMessage<::flow_grpc::DestroyPipeRequest>(Arena*);
template<> ::flow_grpc::EnvDestroyRequest* Arena::CreateMaybeMessage<::flow_grpc::EnvDestroyRequest>(Arena*);
template<> ::flow_grpc::Error* Arena::CreateMaybeMessage<::flow_grpc::Error>(Arena*);
template<> ::flow_grpc::FWD* Arena::CreateMaybeMessage<::flow_grpc::FWD>(Arena*);
template<> ::flow_grpc::FlowPortConfig* Arena::CreateMaybeMessage<::flow_grpc::FlowPortConfig>(Arena*);
template<> ::flow_grpc::GRPCConfig* Arena::CreateMaybeMessage<::flow_grpc::GRPCConfig>(Arena*);
template<> ::flow_grpc::Match* Arena::CreateMaybeMessage<::flow_grpc::Match>(Arena*);
template<> ::flow_grpc::PipeConfig* Arena::CreateMaybeMessage<::flow_grpc::PipeConfig>(Arena*);
template<> ::flow_grpc::PortDumpRequest* Arena::CreateMaybeMessage<::flow_grpc::PortDumpRequest>(Arena*);
template<> ::flow_grpc::PortFlushRequest* Arena::CreateMaybeMessage<::flow_grpc::PortFlushRequest>(Arena*);
template<> ::flow_grpc::PortPairRequest* Arena::CreateMaybeMessage<::flow_grpc::PortPairRequest>(Arena*);
template<> ::flow_grpc::QueryRequest* Arena::CreateMaybeMessage<::flow_grpc::QueryRequest>(Arena*);
template<> ::flow_grpc::Response* Arena::CreateMaybeMessage<::flow_grpc::Response>(Arena*);
template<> ::flow_grpc::RmEntryRequest* Arena::CreateMaybeMessage<::flow_grpc::RmEntryRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flow_grpc {

// ===================================================================

class Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.Response) */ {
 public:
  inline Response() : Response(nullptr) {}
  ~Response() override;
  explicit constexpr Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Response(const Response& from);
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline Response& operator=(Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }
  inline void Swap(Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.Response";
  }
  protected:
  explicit Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipeIdFieldNumber = 1,
  };
  // uint64 pipe_id = 1;
  void clear_pipe_id();
  uint64_t pipe_id() const;
  void set_pipe_id(uint64_t value);
  private:
  uint64_t _internal_pipe_id() const;
  void _internal_set_pipe_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pipe_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Error final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.Error) */ {
 public:
  inline Error() : Error(nullptr) {}
  ~Error() override;
  explicit constexpr Error(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Error(const Error& from);
  Error(Error&& from) noexcept
    : Error() {
    *this = ::std::move(from);
  }

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }
  inline Error& operator=(Error&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Error& default_instance() {
    return *internal_default_instance();
  }
  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Error& a, Error& b) {
    a.Swap(&b);
  }
  inline void Swap(Error* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Error* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Error* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Error>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Error& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Error& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Error* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.Error";
  }
  protected:
  explicit Error(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorMsgFieldNumber = 2,
    kErrorTypeFieldNumber = 1,
  };
  // string error_msg = 2;
  void clear_error_msg();
  const std::string& error_msg() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_msg(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_msg();
  PROTOBUF_NODISCARD std::string* release_error_msg();
  void set_allocated_error_msg(std::string* error_msg);
  private:
  const std::string& _internal_error_msg() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_msg(const std::string& value);
  std::string* _internal_mutable_error_msg();
  public:

  // int32 error_type = 1;
  void clear_error_type();
  int32_t error_type() const;
  void set_error_type(int32_t value);
  private:
  int32_t _internal_error_type() const;
  void _internal_set_error_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.Error)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_msg_;
  int32_t error_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DPDKConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.DPDKConfig) */ {
 public:
  inline DPDKConfig() : DPDKConfig(nullptr) {}
  ~DPDKConfig() override;
  explicit constexpr DPDKConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DPDKConfig(const DPDKConfig& from);
  DPDKConfig(DPDKConfig&& from) noexcept
    : DPDKConfig() {
    *this = ::std::move(from);
  }

  inline DPDKConfig& operator=(const DPDKConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline DPDKConfig& operator=(DPDKConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DPDKConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const DPDKConfig* internal_default_instance() {
    return reinterpret_cast<const DPDKConfig*>(
               &_DPDKConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DPDKConfig& a, DPDKConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(DPDKConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DPDKConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DPDKConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DPDKConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DPDKConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DPDKConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DPDKConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.DPDKConfig";
  }
  protected:
  explicit DPDKConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppPortConfigFieldNumber = 1,
    kReserveMainThreadFieldNumber = 2,
  };
  // .flow_grpc.APPPortConfig app_port_config = 1;
  bool has_app_port_config() const;
  private:
  bool _internal_has_app_port_config() const;
  public:
  void clear_app_port_config();
  const ::flow_grpc::APPPortConfig& app_port_config() const;
  PROTOBUF_NODISCARD ::flow_grpc::APPPortConfig* release_app_port_config();
  ::flow_grpc::APPPortConfig* mutable_app_port_config();
  void set_allocated_app_port_config(::flow_grpc::APPPortConfig* app_port_config);
  private:
  const ::flow_grpc::APPPortConfig& _internal_app_port_config() const;
  ::flow_grpc::APPPortConfig* _internal_mutable_app_port_config();
  public:
  void unsafe_arena_set_allocated_app_port_config(
      ::flow_grpc::APPPortConfig* app_port_config);
  ::flow_grpc::APPPortConfig* unsafe_arena_release_app_port_config();

  // bool reserve_main_thread = 2;
  void clear_reserve_main_thread();
  bool reserve_main_thread() const;
  void set_reserve_main_thread(bool value);
  private:
  bool _internal_reserve_main_thread() const;
  void _internal_set_reserve_main_thread(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.DPDKConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow_grpc::APPPortConfig* app_port_config_;
  bool reserve_main_thread_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class APPPortConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.APPPortConfig) */ {
 public:
  inline APPPortConfig() : APPPortConfig(nullptr) {}
  ~APPPortConfig() override;
  explicit constexpr APPPortConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  APPPortConfig(const APPPortConfig& from);
  APPPortConfig(APPPortConfig&& from) noexcept
    : APPPortConfig() {
    *this = ::std::move(from);
  }

  inline APPPortConfig& operator=(const APPPortConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline APPPortConfig& operator=(APPPortConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const APPPortConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const APPPortConfig* internal_default_instance() {
    return reinterpret_cast<const APPPortConfig*>(
               &_APPPortConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(APPPortConfig& a, APPPortConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(APPPortConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(APPPortConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  APPPortConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<APPPortConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const APPPortConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const APPPortConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(APPPortConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.APPPortConfig";
  }
  protected:
  explicit APPPortConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNbPortsFieldNumber = 1,
    kNbQueuesFieldNumber = 2,
    kNbHairpinQFieldNumber = 3,
  };
  // int32 nb_ports = 1;
  void clear_nb_ports();
  int32_t nb_ports() const;
  void set_nb_ports(int32_t value);
  private:
  int32_t _internal_nb_ports() const;
  void _internal_set_nb_ports(int32_t value);
  public:

  // int32 nb_queues = 2;
  void clear_nb_queues();
  int32_t nb_queues() const;
  void set_nb_queues(int32_t value);
  private:
  int32_t _internal_nb_queues() const;
  void _internal_set_nb_queues(int32_t value);
  public:

  // int32 nb_hairpin_q = 3;
  void clear_nb_hairpin_q();
  int32_t nb_hairpin_q() const;
  void set_nb_hairpin_q(int32_t value);
  private:
  int32_t _internal_nb_hairpin_q() const;
  void _internal_set_nb_hairpin_q(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.APPPortConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t nb_ports_;
  int32_t nb_queues_;
  int32_t nb_hairpin_q_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class GRPCConfig final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow_grpc.GRPCConfig) */ {
 public:
  inline GRPCConfig() : GRPCConfig(nullptr) {}
  explicit constexpr GRPCConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GRPCConfig(const GRPCConfig& from);
  GRPCConfig(GRPCConfig&& from) noexcept
    : GRPCConfig() {
    *this = ::std::move(from);
  }

  inline GRPCConfig& operator=(const GRPCConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline GRPCConfig& operator=(GRPCConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GRPCConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const GRPCConfig* internal_default_instance() {
    return reinterpret_cast<const GRPCConfig*>(
               &_GRPCConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GRPCConfig& a, GRPCConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(GRPCConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GRPCConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GRPCConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GRPCConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GRPCConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GRPCConfig& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.GRPCConfig";
  }
  protected:
  explicit GRPCConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow_grpc.GRPCConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class FlowPortConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.FlowPortConfig) */ {
 public:
  inline FlowPortConfig() : FlowPortConfig(nullptr) {}
  ~FlowPortConfig() override;
  explicit constexpr FlowPortConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FlowPortConfig(const FlowPortConfig& from);
  FlowPortConfig(FlowPortConfig&& from) noexcept
    : FlowPortConfig() {
    *this = ::std::move(from);
  }

  inline FlowPortConfig& operator=(const FlowPortConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline FlowPortConfig& operator=(FlowPortConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FlowPortConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const FlowPortConfig* internal_default_instance() {
    return reinterpret_cast<const FlowPortConfig*>(
               &_FlowPortConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FlowPortConfig& a, FlowPortConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(FlowPortConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FlowPortConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FlowPortConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FlowPortConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FlowPortConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FlowPortConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FlowPortConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.FlowPortConfig";
  }
  protected:
  explicit FlowPortConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
    kPortTypeFieldNumber = 2,
  };
  // uint32 port_id = 1;
  void clear_port_id();
  uint32_t port_id() const;
  void set_port_id(uint32_t value);
  private:
  uint32_t _internal_port_id() const;
  void _internal_set_port_id(uint32_t value);
  public:

  // int32 port_type = 2;
  void clear_port_type();
  int32_t port_type() const;
  void set_port_type(int32_t value);
  private:
  int32_t _internal_port_type() const;
  void _internal_set_port_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.FlowPortConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t port_id_;
  int32_t port_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class PortPairRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.PortPairRequest) */ {
 public:
  inline PortPairRequest() : PortPairRequest(nullptr) {}
  ~PortPairRequest() override;
  explicit constexpr PortPairRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortPairRequest(const PortPairRequest& from);
  PortPairRequest(PortPairRequest&& from) noexcept
    : PortPairRequest() {
    *this = ::std::move(from);
  }

  inline PortPairRequest& operator=(const PortPairRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortPairRequest& operator=(PortPairRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortPairRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortPairRequest* internal_default_instance() {
    return reinterpret_cast<const PortPairRequest*>(
               &_PortPairRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PortPairRequest& a, PortPairRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PortPairRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortPairRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortPairRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortPairRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortPairRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortPairRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortPairRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.PortPairRequest";
  }
  protected:
  explicit PortPairRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortId1FieldNumber = 1,
    kPortId2FieldNumber = 2,
  };
  // uint32 port_id1 = 1;
  void clear_port_id1();
  uint32_t port_id1() const;
  void set_port_id1(uint32_t value);
  private:
  uint32_t _internal_port_id1() const;
  void _internal_set_port_id1(uint32_t value);
  public:

  // uint32 port_id2 = 2;
  void clear_port_id2();
  uint32_t port_id2() const;
  void set_port_id2(uint32_t value);
  private:
  uint32_t _internal_port_id2() const;
  void _internal_set_port_id2(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.PortPairRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t port_id1_;
  uint32_t port_id2_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class PipeConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.PipeConfig) */ {
 public:
  inline PipeConfig() : PipeConfig(nullptr) {}
  ~PipeConfig() override;
  explicit constexpr PipeConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PipeConfig(const PipeConfig& from);
  PipeConfig(PipeConfig&& from) noexcept
    : PipeConfig() {
    *this = ::std::move(from);
  }

  inline PipeConfig& operator=(const PipeConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PipeConfig& operator=(PipeConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PipeConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PipeConfig* internal_default_instance() {
    return reinterpret_cast<const PipeConfig*>(
               &_PipeConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PipeConfig& a, PipeConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PipeConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PipeConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PipeConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PipeConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PipeConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PipeConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PipeConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.PipeConfig";
  }
  protected:
  explicit PipeConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kMatchFieldNumber = 5,
    kActionFieldNumber = 6,
    kTypeFieldNumber = 2,
    kPortIdFieldNumber = 3,
    kIsRootFieldNumber = 4,
    kNbFlowsFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .flow_grpc.Match match = 5;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::flow_grpc::Match& match() const;
  PROTOBUF_NODISCARD ::flow_grpc::Match* release_match();
  ::flow_grpc::Match* mutable_match();
  void set_allocated_match(::flow_grpc::Match* match);
  private:
  const ::flow_grpc::Match& _internal_match() const;
  ::flow_grpc::Match* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::flow_grpc::Match* match);
  ::flow_grpc::Match* unsafe_arena_release_match();

  // .flow_grpc.Action action = 6;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::flow_grpc::Action& action() const;
  PROTOBUF_NODISCARD ::flow_grpc::Action* release_action();
  ::flow_grpc::Action* mutable_action();
  void set_allocated_action(::flow_grpc::Action* action);
  private:
  const ::flow_grpc::Action& _internal_action() const;
  ::flow_grpc::Action* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::flow_grpc::Action* action);
  ::flow_grpc::Action* unsafe_arena_release_action();

  // int32 type = 2;
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // uint32 port_id = 3;
  void clear_port_id();
  uint32_t port_id() const;
  void set_port_id(uint32_t value);
  private:
  uint32_t _internal_port_id() const;
  void _internal_set_port_id(uint32_t value);
  public:

  // bool is_root = 4;
  void clear_is_root();
  bool is_root() const;
  void set_is_root(bool value);
  private:
  bool _internal_is_root() const;
  void _internal_set_is_root(bool value);
  public:

  // uint32 nb_flows = 7;
  void clear_nb_flows();
  uint32_t nb_flows() const;
  void set_nb_flows(uint32_t value);
  private:
  uint32_t _internal_nb_flows() const;
  void _internal_set_nb_flows(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.PipeConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::flow_grpc::Match* match_;
  ::flow_grpc::Action* action_;
  int32_t type_;
  uint32_t port_id_;
  bool is_root_;
  uint32_t nb_flows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Match final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.Match) */ {
 public:
  inline Match() : Match(nullptr) {}
  ~Match() override;
  explicit constexpr Match(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Match(const Match& from);
  Match(Match&& from) noexcept
    : Match() {
    *this = ::std::move(from);
  }

  inline Match& operator=(const Match& from) {
    CopyFrom(from);
    return *this;
  }
  inline Match& operator=(Match&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Match& default_instance() {
    return *internal_default_instance();
  }
  static inline const Match* internal_default_instance() {
    return reinterpret_cast<const Match*>(
               &_Match_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Match& a, Match& b) {
    a.Swap(&b);
  }
  inline void Swap(Match* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Match* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Match* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Match>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Match& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Match& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Match* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.Match";
  }
  protected:
  explicit Match(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchRuleFieldNumber = 1,
  };
  // string match_rule = 1;
  void clear_match_rule();
  const std::string& match_rule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_match_rule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_match_rule();
  PROTOBUF_NODISCARD std::string* release_match_rule();
  void set_allocated_match_rule(std::string* match_rule);
  private:
  const std::string& _internal_match_rule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_match_rule(const std::string& value);
  std::string* _internal_mutable_match_rule();
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.Match)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr match_rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class Action final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.Action) */ {
 public:
  inline Action() : Action(nullptr) {}
  ~Action() override;
  explicit constexpr Action(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Action(const Action& from);
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  inline Action& operator=(Action&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Action& default_instance() {
    return *internal_default_instance();
  }
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }
  inline void Swap(Action* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Action* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Action* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Action& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Action& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.Action";
  }
  protected:
  explicit Action(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionRuleFieldNumber = 1,
  };
  // string action_rule = 1;
  void clear_action_rule();
  const std::string& action_rule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_rule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_rule();
  PROTOBUF_NODISCARD std::string* release_action_rule();
  void set_allocated_action_rule(std::string* action_rule);
  private:
  const std::string& _internal_action_rule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_rule(const std::string& value);
  std::string* _internal_mutable_action_rule();
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.Action)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class FWD final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.FWD) */ {
 public:
  inline FWD() : FWD(nullptr) {}
  ~FWD() override;
  explicit constexpr FWD(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FWD(const FWD& from);
  FWD(FWD&& from) noexcept
    : FWD() {
    *this = ::std::move(from);
  }

  inline FWD& operator=(const FWD& from) {
    CopyFrom(from);
    return *this;
  }
  inline FWD& operator=(FWD&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FWD& default_instance() {
    return *internal_default_instance();
  }
  static inline const FWD* internal_default_instance() {
    return reinterpret_cast<const FWD*>(
               &_FWD_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(FWD& a, FWD& b) {
    a.Swap(&b);
  }
  inline void Swap(FWD* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FWD* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FWD* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FWD>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FWD& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FWD& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FWD* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.FWD";
  }
  protected:
  explicit FWD(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFwdRuleFieldNumber = 1,
  };
  // string fwd_rule = 1;
  void clear_fwd_rule();
  const std::string& fwd_rule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fwd_rule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fwd_rule();
  PROTOBUF_NODISCARD std::string* release_fwd_rule();
  void set_allocated_fwd_rule(std::string* fwd_rule);
  private:
  const std::string& _internal_fwd_rule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fwd_rule(const std::string& value);
  std::string* _internal_mutable_fwd_rule();
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.FWD)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fwd_rule_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class CreatePipeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.CreatePipeRequest) */ {
 public:
  inline CreatePipeRequest() : CreatePipeRequest(nullptr) {}
  ~CreatePipeRequest() override;
  explicit constexpr CreatePipeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreatePipeRequest(const CreatePipeRequest& from);
  CreatePipeRequest(CreatePipeRequest&& from) noexcept
    : CreatePipeRequest() {
    *this = ::std::move(from);
  }

  inline CreatePipeRequest& operator=(const CreatePipeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreatePipeRequest& operator=(CreatePipeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreatePipeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreatePipeRequest* internal_default_instance() {
    return reinterpret_cast<const CreatePipeRequest*>(
               &_CreatePipeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CreatePipeRequest& a, CreatePipeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreatePipeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreatePipeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreatePipeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreatePipeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreatePipeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CreatePipeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePipeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.CreatePipeRequest";
  }
  protected:
  explicit CreatePipeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipeConfigFieldNumber = 1,
    kFwdFieldNumber = 2,
    kFwdMissFieldNumber = 3,
  };
  // .flow_grpc.PipeConfig pipe_config = 1;
  bool has_pipe_config() const;
  private:
  bool _internal_has_pipe_config() const;
  public:
  void clear_pipe_config();
  const ::flow_grpc::PipeConfig& pipe_config() const;
  PROTOBUF_NODISCARD ::flow_grpc::PipeConfig* release_pipe_config();
  ::flow_grpc::PipeConfig* mutable_pipe_config();
  void set_allocated_pipe_config(::flow_grpc::PipeConfig* pipe_config);
  private:
  const ::flow_grpc::PipeConfig& _internal_pipe_config() const;
  ::flow_grpc::PipeConfig* _internal_mutable_pipe_config();
  public:
  void unsafe_arena_set_allocated_pipe_config(
      ::flow_grpc::PipeConfig* pipe_config);
  ::flow_grpc::PipeConfig* unsafe_arena_release_pipe_config();

  // .flow_grpc.FWD fwd = 2;
  bool has_fwd() const;
  private:
  bool _internal_has_fwd() const;
  public:
  void clear_fwd();
  const ::flow_grpc::FWD& fwd() const;
  PROTOBUF_NODISCARD ::flow_grpc::FWD* release_fwd();
  ::flow_grpc::FWD* mutable_fwd();
  void set_allocated_fwd(::flow_grpc::FWD* fwd);
  private:
  const ::flow_grpc::FWD& _internal_fwd() const;
  ::flow_grpc::FWD* _internal_mutable_fwd();
  public:
  void unsafe_arena_set_allocated_fwd(
      ::flow_grpc::FWD* fwd);
  ::flow_grpc::FWD* unsafe_arena_release_fwd();

  // .flow_grpc.FWD fwd_miss = 3;
  bool has_fwd_miss() const;
  private:
  bool _internal_has_fwd_miss() const;
  public:
  void clear_fwd_miss();
  const ::flow_grpc::FWD& fwd_miss() const;
  PROTOBUF_NODISCARD ::flow_grpc::FWD* release_fwd_miss();
  ::flow_grpc::FWD* mutable_fwd_miss();
  void set_allocated_fwd_miss(::flow_grpc::FWD* fwd_miss);
  private:
  const ::flow_grpc::FWD& _internal_fwd_miss() const;
  ::flow_grpc::FWD* _internal_mutable_fwd_miss();
  public:
  void unsafe_arena_set_allocated_fwd_miss(
      ::flow_grpc::FWD* fwd_miss);
  ::flow_grpc::FWD* unsafe_arena_release_fwd_miss();

  // @@protoc_insertion_point(class_scope:flow_grpc.CreatePipeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow_grpc::PipeConfig* pipe_config_;
  ::flow_grpc::FWD* fwd_;
  ::flow_grpc::FWD* fwd_miss_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class AddEntryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.AddEntryRequest) */ {
 public:
  inline AddEntryRequest() : AddEntryRequest(nullptr) {}
  ~AddEntryRequest() override;
  explicit constexpr AddEntryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddEntryRequest(const AddEntryRequest& from);
  AddEntryRequest(AddEntryRequest&& from) noexcept
    : AddEntryRequest() {
    *this = ::std::move(from);
  }

  inline AddEntryRequest& operator=(const AddEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddEntryRequest& operator=(AddEntryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddEntryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddEntryRequest* internal_default_instance() {
    return reinterpret_cast<const AddEntryRequest*>(
               &_AddEntryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(AddEntryRequest& a, AddEntryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddEntryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddEntryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddEntryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddEntryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddEntryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddEntryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddEntryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.AddEntryRequest";
  }
  protected:
  explicit AddEntryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMatchFieldNumber = 3,
    kActionFieldNumber = 4,
    kFwdFieldNumber = 5,
    kPipeIdFieldNumber = 2,
    kPipeQueueFieldNumber = 1,
    kFlagsFieldNumber = 6,
  };
  // .flow_grpc.Match match = 3;
  bool has_match() const;
  private:
  bool _internal_has_match() const;
  public:
  void clear_match();
  const ::flow_grpc::Match& match() const;
  PROTOBUF_NODISCARD ::flow_grpc::Match* release_match();
  ::flow_grpc::Match* mutable_match();
  void set_allocated_match(::flow_grpc::Match* match);
  private:
  const ::flow_grpc::Match& _internal_match() const;
  ::flow_grpc::Match* _internal_mutable_match();
  public:
  void unsafe_arena_set_allocated_match(
      ::flow_grpc::Match* match);
  ::flow_grpc::Match* unsafe_arena_release_match();

  // .flow_grpc.Action action = 4;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  const ::flow_grpc::Action& action() const;
  PROTOBUF_NODISCARD ::flow_grpc::Action* release_action();
  ::flow_grpc::Action* mutable_action();
  void set_allocated_action(::flow_grpc::Action* action);
  private:
  const ::flow_grpc::Action& _internal_action() const;
  ::flow_grpc::Action* _internal_mutable_action();
  public:
  void unsafe_arena_set_allocated_action(
      ::flow_grpc::Action* action);
  ::flow_grpc::Action* unsafe_arena_release_action();

  // .flow_grpc.FWD fwd = 5;
  bool has_fwd() const;
  private:
  bool _internal_has_fwd() const;
  public:
  void clear_fwd();
  const ::flow_grpc::FWD& fwd() const;
  PROTOBUF_NODISCARD ::flow_grpc::FWD* release_fwd();
  ::flow_grpc::FWD* mutable_fwd();
  void set_allocated_fwd(::flow_grpc::FWD* fwd);
  private:
  const ::flow_grpc::FWD& _internal_fwd() const;
  ::flow_grpc::FWD* _internal_mutable_fwd();
  public:
  void unsafe_arena_set_allocated_fwd(
      ::flow_grpc::FWD* fwd);
  ::flow_grpc::FWD* unsafe_arena_release_fwd();

  // uint64 pipe_id = 2;
  void clear_pipe_id();
  uint64_t pipe_id() const;
  void set_pipe_id(uint64_t value);
  private:
  uint64_t _internal_pipe_id() const;
  void _internal_set_pipe_id(uint64_t value);
  public:

  // uint32 pipe_queue = 1;
  void clear_pipe_queue();
  uint32_t pipe_queue() const;
  void set_pipe_queue(uint32_t value);
  private:
  uint32_t _internal_pipe_queue() const;
  void _internal_set_pipe_queue(uint32_t value);
  public:

  // uint32 flags = 6;
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.AddEntryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow_grpc::Match* match_;
  ::flow_grpc::Action* action_;
  ::flow_grpc::FWD* fwd_;
  uint64_t pipe_id_;
  uint32_t pipe_queue_;
  uint32_t flags_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class PortDumpRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.PortDumpRequest) */ {
 public:
  inline PortDumpRequest() : PortDumpRequest(nullptr) {}
  ~PortDumpRequest() override;
  explicit constexpr PortDumpRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortDumpRequest(const PortDumpRequest& from);
  PortDumpRequest(PortDumpRequest&& from) noexcept
    : PortDumpRequest() {
    *this = ::std::move(from);
  }

  inline PortDumpRequest& operator=(const PortDumpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortDumpRequest& operator=(PortDumpRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortDumpRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortDumpRequest* internal_default_instance() {
    return reinterpret_cast<const PortDumpRequest*>(
               &_PortDumpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(PortDumpRequest& a, PortDumpRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PortDumpRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortDumpRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortDumpRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortDumpRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortDumpRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortDumpRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortDumpRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.PortDumpRequest";
  }
  protected:
  explicit PortDumpRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 2,
    kPortIdFieldNumber = 1,
  };
  // string result = 2;
  void clear_result();
  const std::string& result() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_result(ArgT0&& arg0, ArgT... args);
  std::string* mutable_result();
  PROTOBUF_NODISCARD std::string* release_result();
  void set_allocated_result(std::string* result);
  private:
  const std::string& _internal_result() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_result(const std::string& value);
  std::string* _internal_mutable_result();
  public:

  // uint32 port_id = 1;
  void clear_port_id();
  uint32_t port_id() const;
  void set_port_id(uint32_t value);
  private:
  uint32_t _internal_port_id() const;
  void _internal_set_port_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.PortDumpRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr result_;
  uint32_t port_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class QueryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.QueryRequest) */ {
 public:
  inline QueryRequest() : QueryRequest(nullptr) {}
  ~QueryRequest() override;
  explicit constexpr QueryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QueryRequest(const QueryRequest& from);
  QueryRequest(QueryRequest&& from) noexcept
    : QueryRequest() {
    *this = ::std::move(from);
  }

  inline QueryRequest& operator=(const QueryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QueryRequest& operator=(QueryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QueryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QueryRequest* internal_default_instance() {
    return reinterpret_cast<const QueryRequest*>(
               &_QueryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(QueryRequest& a, QueryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QueryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QueryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QueryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QueryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QueryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const QueryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QueryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.QueryRequest";
  }
  protected:
  explicit QueryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryIdFieldNumber = 1,
    kTotalBytesFieldNumber = 2,
    kTotalPktsFieldNumber = 3,
  };
  // uint64 entry_id = 1;
  void clear_entry_id();
  uint64_t entry_id() const;
  void set_entry_id(uint64_t value);
  private:
  uint64_t _internal_entry_id() const;
  void _internal_set_entry_id(uint64_t value);
  public:

  // uint64 total_bytes = 2;
  void clear_total_bytes();
  uint64_t total_bytes() const;
  void set_total_bytes(uint64_t value);
  private:
  uint64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(uint64_t value);
  public:

  // uint64 total_pkts = 3;
  void clear_total_pkts();
  uint64_t total_pkts() const;
  void set_total_pkts(uint64_t value);
  private:
  uint64_t _internal_total_pkts() const;
  void _internal_set_total_pkts(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.QueryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t entry_id_;
  uint64_t total_bytes_;
  uint64_t total_pkts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class PortFlushRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.PortFlushRequest) */ {
 public:
  inline PortFlushRequest() : PortFlushRequest(nullptr) {}
  ~PortFlushRequest() override;
  explicit constexpr PortFlushRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PortFlushRequest(const PortFlushRequest& from);
  PortFlushRequest(PortFlushRequest&& from) noexcept
    : PortFlushRequest() {
    *this = ::std::move(from);
  }

  inline PortFlushRequest& operator=(const PortFlushRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PortFlushRequest& operator=(PortFlushRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PortFlushRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PortFlushRequest* internal_default_instance() {
    return reinterpret_cast<const PortFlushRequest*>(
               &_PortFlushRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PortFlushRequest& a, PortFlushRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PortFlushRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PortFlushRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PortFlushRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PortFlushRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PortFlushRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PortFlushRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PortFlushRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.PortFlushRequest";
  }
  protected:
  explicit PortFlushRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPortIdFieldNumber = 1,
  };
  // uint32 port_id = 1;
  void clear_port_id();
  uint32_t port_id() const;
  void set_port_id(uint32_t value);
  private:
  uint32_t _internal_port_id() const;
  void _internal_set_port_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.PortFlushRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint32_t port_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class RmEntryRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.RmEntryRequest) */ {
 public:
  inline RmEntryRequest() : RmEntryRequest(nullptr) {}
  ~RmEntryRequest() override;
  explicit constexpr RmEntryRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RmEntryRequest(const RmEntryRequest& from);
  RmEntryRequest(RmEntryRequest&& from) noexcept
    : RmEntryRequest() {
    *this = ::std::move(from);
  }

  inline RmEntryRequest& operator=(const RmEntryRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RmEntryRequest& operator=(RmEntryRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RmEntryRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RmEntryRequest* internal_default_instance() {
    return reinterpret_cast<const RmEntryRequest*>(
               &_RmEntryRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RmEntryRequest& a, RmEntryRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RmEntryRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RmEntryRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RmEntryRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RmEntryRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RmEntryRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RmEntryRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RmEntryRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.RmEntryRequest";
  }
  protected:
  explicit RmEntryRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntryIdFieldNumber = 2,
    kPipeQueueFieldNumber = 1,
  };
  // uint64 entry_id = 2;
  void clear_entry_id();
  uint64_t entry_id() const;
  void set_entry_id(uint64_t value);
  private:
  uint64_t _internal_entry_id() const;
  void _internal_set_entry_id(uint64_t value);
  public:

  // uint32 pipe_queue = 1;
  void clear_pipe_queue();
  uint32_t pipe_queue() const;
  void set_pipe_queue(uint32_t value);
  private:
  uint32_t _internal_pipe_queue() const;
  void _internal_set_pipe_queue(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.RmEntryRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t entry_id_;
  uint32_t pipe_queue_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class DestroyPipeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow_grpc.DestroyPipeRequest) */ {
 public:
  inline DestroyPipeRequest() : DestroyPipeRequest(nullptr) {}
  ~DestroyPipeRequest() override;
  explicit constexpr DestroyPipeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DestroyPipeRequest(const DestroyPipeRequest& from);
  DestroyPipeRequest(DestroyPipeRequest&& from) noexcept
    : DestroyPipeRequest() {
    *this = ::std::move(from);
  }

  inline DestroyPipeRequest& operator=(const DestroyPipeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DestroyPipeRequest& operator=(DestroyPipeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DestroyPipeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DestroyPipeRequest* internal_default_instance() {
    return reinterpret_cast<const DestroyPipeRequest*>(
               &_DestroyPipeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DestroyPipeRequest& a, DestroyPipeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DestroyPipeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DestroyPipeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DestroyPipeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DestroyPipeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DestroyPipeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DestroyPipeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DestroyPipeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.DestroyPipeRequest";
  }
  protected:
  explicit DestroyPipeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPipeIdFieldNumber = 2,
    kPortIdFieldNumber = 1,
  };
  // uint64 pipe_id = 2;
  void clear_pipe_id();
  uint64_t pipe_id() const;
  void set_pipe_id(uint64_t value);
  private:
  uint64_t _internal_pipe_id() const;
  void _internal_set_pipe_id(uint64_t value);
  public:

  // uint32 port_id = 1;
  void clear_port_id();
  uint32_t port_id() const;
  void set_port_id(uint32_t value);
  private:
  uint32_t _internal_port_id() const;
  void _internal_set_port_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:flow_grpc.DestroyPipeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  uint64_t pipe_id_;
  uint32_t port_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// -------------------------------------------------------------------

class EnvDestroyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:flow_grpc.EnvDestroyRequest) */ {
 public:
  inline EnvDestroyRequest() : EnvDestroyRequest(nullptr) {}
  explicit constexpr EnvDestroyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EnvDestroyRequest(const EnvDestroyRequest& from);
  EnvDestroyRequest(EnvDestroyRequest&& from) noexcept
    : EnvDestroyRequest() {
    *this = ::std::move(from);
  }

  inline EnvDestroyRequest& operator=(const EnvDestroyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnvDestroyRequest& operator=(EnvDestroyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnvDestroyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnvDestroyRequest* internal_default_instance() {
    return reinterpret_cast<const EnvDestroyRequest*>(
               &_EnvDestroyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(EnvDestroyRequest& a, EnvDestroyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(EnvDestroyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnvDestroyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnvDestroyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnvDestroyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EnvDestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EnvDestroyRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow_grpc.EnvDestroyRequest";
  }
  protected:
  explicit EnvDestroyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow_grpc.EnvDestroyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_5fgrpc_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Response

// uint64 pipe_id = 1;
inline void Response::clear_pipe_id() {
  pipe_id_ = uint64_t{0u};
}
inline uint64_t Response::_internal_pipe_id() const {
  return pipe_id_;
}
inline uint64_t Response::pipe_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.Response.pipe_id)
  return _internal_pipe_id();
}
inline void Response::_internal_set_pipe_id(uint64_t value) {
  
  pipe_id_ = value;
}
inline void Response::set_pipe_id(uint64_t value) {
  _internal_set_pipe_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.Response.pipe_id)
}

// -------------------------------------------------------------------

// Error

// int32 error_type = 1;
inline void Error::clear_error_type() {
  error_type_ = 0;
}
inline int32_t Error::_internal_error_type() const {
  return error_type_;
}
inline int32_t Error::error_type() const {
  // @@protoc_insertion_point(field_get:flow_grpc.Error.error_type)
  return _internal_error_type();
}
inline void Error::_internal_set_error_type(int32_t value) {
  
  error_type_ = value;
}
inline void Error::set_error_type(int32_t value) {
  _internal_set_error_type(value);
  // @@protoc_insertion_point(field_set:flow_grpc.Error.error_type)
}

// string error_msg = 2;
inline void Error::clear_error_msg() {
  error_msg_.ClearToEmpty();
}
inline const std::string& Error::error_msg() const {
  // @@protoc_insertion_point(field_get:flow_grpc.Error.error_msg)
  return _internal_error_msg();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Error::set_error_msg(ArgT0&& arg0, ArgT... args) {
 
 error_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow_grpc.Error.error_msg)
}
inline std::string* Error::mutable_error_msg() {
  std::string* _s = _internal_mutable_error_msg();
  // @@protoc_insertion_point(field_mutable:flow_grpc.Error.error_msg)
  return _s;
}
inline const std::string& Error::_internal_error_msg() const {
  return error_msg_.Get();
}
inline void Error::_internal_set_error_msg(const std::string& value) {
  
  error_msg_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Error::_internal_mutable_error_msg() {
  
  return error_msg_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Error::release_error_msg() {
  // @@protoc_insertion_point(field_release:flow_grpc.Error.error_msg)
  return error_msg_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Error::set_allocated_error_msg(std::string* error_msg) {
  if (error_msg != nullptr) {
    
  } else {
    
  }
  error_msg_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_msg,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_msg_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_msg_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.Error.error_msg)
}

// -------------------------------------------------------------------

// DPDKConfig

// .flow_grpc.APPPortConfig app_port_config = 1;
inline bool DPDKConfig::_internal_has_app_port_config() const {
  return this != internal_default_instance() && app_port_config_ != nullptr;
}
inline bool DPDKConfig::has_app_port_config() const {
  return _internal_has_app_port_config();
}
inline void DPDKConfig::clear_app_port_config() {
  if (GetArenaForAllocation() == nullptr && app_port_config_ != nullptr) {
    delete app_port_config_;
  }
  app_port_config_ = nullptr;
}
inline const ::flow_grpc::APPPortConfig& DPDKConfig::_internal_app_port_config() const {
  const ::flow_grpc::APPPortConfig* p = app_port_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::APPPortConfig&>(
      ::flow_grpc::_APPPortConfig_default_instance_);
}
inline const ::flow_grpc::APPPortConfig& DPDKConfig::app_port_config() const {
  // @@protoc_insertion_point(field_get:flow_grpc.DPDKConfig.app_port_config)
  return _internal_app_port_config();
}
inline void DPDKConfig::unsafe_arena_set_allocated_app_port_config(
    ::flow_grpc::APPPortConfig* app_port_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(app_port_config_);
  }
  app_port_config_ = app_port_config;
  if (app_port_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.DPDKConfig.app_port_config)
}
inline ::flow_grpc::APPPortConfig* DPDKConfig::release_app_port_config() {
  
  ::flow_grpc::APPPortConfig* temp = app_port_config_;
  app_port_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::APPPortConfig* DPDKConfig::unsafe_arena_release_app_port_config() {
  // @@protoc_insertion_point(field_release:flow_grpc.DPDKConfig.app_port_config)
  
  ::flow_grpc::APPPortConfig* temp = app_port_config_;
  app_port_config_ = nullptr;
  return temp;
}
inline ::flow_grpc::APPPortConfig* DPDKConfig::_internal_mutable_app_port_config() {
  
  if (app_port_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::APPPortConfig>(GetArenaForAllocation());
    app_port_config_ = p;
  }
  return app_port_config_;
}
inline ::flow_grpc::APPPortConfig* DPDKConfig::mutable_app_port_config() {
  ::flow_grpc::APPPortConfig* _msg = _internal_mutable_app_port_config();
  // @@protoc_insertion_point(field_mutable:flow_grpc.DPDKConfig.app_port_config)
  return _msg;
}
inline void DPDKConfig::set_allocated_app_port_config(::flow_grpc::APPPortConfig* app_port_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete app_port_config_;
  }
  if (app_port_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::APPPortConfig>::GetOwningArena(app_port_config);
    if (message_arena != submessage_arena) {
      app_port_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, app_port_config, submessage_arena);
    }
    
  } else {
    
  }
  app_port_config_ = app_port_config;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.DPDKConfig.app_port_config)
}

// bool reserve_main_thread = 2;
inline void DPDKConfig::clear_reserve_main_thread() {
  reserve_main_thread_ = false;
}
inline bool DPDKConfig::_internal_reserve_main_thread() const {
  return reserve_main_thread_;
}
inline bool DPDKConfig::reserve_main_thread() const {
  // @@protoc_insertion_point(field_get:flow_grpc.DPDKConfig.reserve_main_thread)
  return _internal_reserve_main_thread();
}
inline void DPDKConfig::_internal_set_reserve_main_thread(bool value) {
  
  reserve_main_thread_ = value;
}
inline void DPDKConfig::set_reserve_main_thread(bool value) {
  _internal_set_reserve_main_thread(value);
  // @@protoc_insertion_point(field_set:flow_grpc.DPDKConfig.reserve_main_thread)
}

// -------------------------------------------------------------------

// APPPortConfig

// int32 nb_ports = 1;
inline void APPPortConfig::clear_nb_ports() {
  nb_ports_ = 0;
}
inline int32_t APPPortConfig::_internal_nb_ports() const {
  return nb_ports_;
}
inline int32_t APPPortConfig::nb_ports() const {
  // @@protoc_insertion_point(field_get:flow_grpc.APPPortConfig.nb_ports)
  return _internal_nb_ports();
}
inline void APPPortConfig::_internal_set_nb_ports(int32_t value) {
  
  nb_ports_ = value;
}
inline void APPPortConfig::set_nb_ports(int32_t value) {
  _internal_set_nb_ports(value);
  // @@protoc_insertion_point(field_set:flow_grpc.APPPortConfig.nb_ports)
}

// int32 nb_queues = 2;
inline void APPPortConfig::clear_nb_queues() {
  nb_queues_ = 0;
}
inline int32_t APPPortConfig::_internal_nb_queues() const {
  return nb_queues_;
}
inline int32_t APPPortConfig::nb_queues() const {
  // @@protoc_insertion_point(field_get:flow_grpc.APPPortConfig.nb_queues)
  return _internal_nb_queues();
}
inline void APPPortConfig::_internal_set_nb_queues(int32_t value) {
  
  nb_queues_ = value;
}
inline void APPPortConfig::set_nb_queues(int32_t value) {
  _internal_set_nb_queues(value);
  // @@protoc_insertion_point(field_set:flow_grpc.APPPortConfig.nb_queues)
}

// int32 nb_hairpin_q = 3;
inline void APPPortConfig::clear_nb_hairpin_q() {
  nb_hairpin_q_ = 0;
}
inline int32_t APPPortConfig::_internal_nb_hairpin_q() const {
  return nb_hairpin_q_;
}
inline int32_t APPPortConfig::nb_hairpin_q() const {
  // @@protoc_insertion_point(field_get:flow_grpc.APPPortConfig.nb_hairpin_q)
  return _internal_nb_hairpin_q();
}
inline void APPPortConfig::_internal_set_nb_hairpin_q(int32_t value) {
  
  nb_hairpin_q_ = value;
}
inline void APPPortConfig::set_nb_hairpin_q(int32_t value) {
  _internal_set_nb_hairpin_q(value);
  // @@protoc_insertion_point(field_set:flow_grpc.APPPortConfig.nb_hairpin_q)
}

// -------------------------------------------------------------------

// GRPCConfig

// -------------------------------------------------------------------

// FlowPortConfig

// uint32 port_id = 1;
inline void FlowPortConfig::clear_port_id() {
  port_id_ = 0u;
}
inline uint32_t FlowPortConfig::_internal_port_id() const {
  return port_id_;
}
inline uint32_t FlowPortConfig::port_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.FlowPortConfig.port_id)
  return _internal_port_id();
}
inline void FlowPortConfig::_internal_set_port_id(uint32_t value) {
  
  port_id_ = value;
}
inline void FlowPortConfig::set_port_id(uint32_t value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.FlowPortConfig.port_id)
}

// int32 port_type = 2;
inline void FlowPortConfig::clear_port_type() {
  port_type_ = 0;
}
inline int32_t FlowPortConfig::_internal_port_type() const {
  return port_type_;
}
inline int32_t FlowPortConfig::port_type() const {
  // @@protoc_insertion_point(field_get:flow_grpc.FlowPortConfig.port_type)
  return _internal_port_type();
}
inline void FlowPortConfig::_internal_set_port_type(int32_t value) {
  
  port_type_ = value;
}
inline void FlowPortConfig::set_port_type(int32_t value) {
  _internal_set_port_type(value);
  // @@protoc_insertion_point(field_set:flow_grpc.FlowPortConfig.port_type)
}

// -------------------------------------------------------------------

// PortPairRequest

// uint32 port_id1 = 1;
inline void PortPairRequest::clear_port_id1() {
  port_id1_ = 0u;
}
inline uint32_t PortPairRequest::_internal_port_id1() const {
  return port_id1_;
}
inline uint32_t PortPairRequest::port_id1() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PortPairRequest.port_id1)
  return _internal_port_id1();
}
inline void PortPairRequest::_internal_set_port_id1(uint32_t value) {
  
  port_id1_ = value;
}
inline void PortPairRequest::set_port_id1(uint32_t value) {
  _internal_set_port_id1(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PortPairRequest.port_id1)
}

// uint32 port_id2 = 2;
inline void PortPairRequest::clear_port_id2() {
  port_id2_ = 0u;
}
inline uint32_t PortPairRequest::_internal_port_id2() const {
  return port_id2_;
}
inline uint32_t PortPairRequest::port_id2() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PortPairRequest.port_id2)
  return _internal_port_id2();
}
inline void PortPairRequest::_internal_set_port_id2(uint32_t value) {
  
  port_id2_ = value;
}
inline void PortPairRequest::set_port_id2(uint32_t value) {
  _internal_set_port_id2(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PortPairRequest.port_id2)
}

// -------------------------------------------------------------------

// PipeConfig

// string name = 1;
inline void PipeConfig::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PipeConfig::name() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PipeConfig::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow_grpc.PipeConfig.name)
}
inline std::string* PipeConfig::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:flow_grpc.PipeConfig.name)
  return _s;
}
inline const std::string& PipeConfig::_internal_name() const {
  return name_.Get();
}
inline void PipeConfig::_internal_set_name(const std::string& value) {
  
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PipeConfig::_internal_mutable_name() {
  
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PipeConfig::release_name() {
  // @@protoc_insertion_point(field_release:flow_grpc.PipeConfig.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PipeConfig::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.PipeConfig.name)
}

// int32 type = 2;
inline void PipeConfig::clear_type() {
  type_ = 0;
}
inline int32_t PipeConfig::_internal_type() const {
  return type_;
}
inline int32_t PipeConfig::type() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.type)
  return _internal_type();
}
inline void PipeConfig::_internal_set_type(int32_t value) {
  
  type_ = value;
}
inline void PipeConfig::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PipeConfig.type)
}

// uint32 port_id = 3;
inline void PipeConfig::clear_port_id() {
  port_id_ = 0u;
}
inline uint32_t PipeConfig::_internal_port_id() const {
  return port_id_;
}
inline uint32_t PipeConfig::port_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.port_id)
  return _internal_port_id();
}
inline void PipeConfig::_internal_set_port_id(uint32_t value) {
  
  port_id_ = value;
}
inline void PipeConfig::set_port_id(uint32_t value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PipeConfig.port_id)
}

// bool is_root = 4;
inline void PipeConfig::clear_is_root() {
  is_root_ = false;
}
inline bool PipeConfig::_internal_is_root() const {
  return is_root_;
}
inline bool PipeConfig::is_root() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.is_root)
  return _internal_is_root();
}
inline void PipeConfig::_internal_set_is_root(bool value) {
  
  is_root_ = value;
}
inline void PipeConfig::set_is_root(bool value) {
  _internal_set_is_root(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PipeConfig.is_root)
}

// .flow_grpc.Match match = 5;
inline bool PipeConfig::_internal_has_match() const {
  return this != internal_default_instance() && match_ != nullptr;
}
inline bool PipeConfig::has_match() const {
  return _internal_has_match();
}
inline void PipeConfig::clear_match() {
  if (GetArenaForAllocation() == nullptr && match_ != nullptr) {
    delete match_;
  }
  match_ = nullptr;
}
inline const ::flow_grpc::Match& PipeConfig::_internal_match() const {
  const ::flow_grpc::Match* p = match_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::Match&>(
      ::flow_grpc::_Match_default_instance_);
}
inline const ::flow_grpc::Match& PipeConfig::match() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.match)
  return _internal_match();
}
inline void PipeConfig::unsafe_arena_set_allocated_match(
    ::flow_grpc::Match* match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_);
  }
  match_ = match;
  if (match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.PipeConfig.match)
}
inline ::flow_grpc::Match* PipeConfig::release_match() {
  
  ::flow_grpc::Match* temp = match_;
  match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::Match* PipeConfig::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_release:flow_grpc.PipeConfig.match)
  
  ::flow_grpc::Match* temp = match_;
  match_ = nullptr;
  return temp;
}
inline ::flow_grpc::Match* PipeConfig::_internal_mutable_match() {
  
  if (match_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::Match>(GetArenaForAllocation());
    match_ = p;
  }
  return match_;
}
inline ::flow_grpc::Match* PipeConfig::mutable_match() {
  ::flow_grpc::Match* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:flow_grpc.PipeConfig.match)
  return _msg;
}
inline void PipeConfig::set_allocated_match(::flow_grpc::Match* match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_;
  }
  if (match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::Match>::GetOwningArena(match);
    if (message_arena != submessage_arena) {
      match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    
  } else {
    
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.PipeConfig.match)
}

// .flow_grpc.Action action = 6;
inline bool PipeConfig::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool PipeConfig::has_action() const {
  return _internal_has_action();
}
inline void PipeConfig::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::flow_grpc::Action& PipeConfig::_internal_action() const {
  const ::flow_grpc::Action* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::Action&>(
      ::flow_grpc::_Action_default_instance_);
}
inline const ::flow_grpc::Action& PipeConfig::action() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.action)
  return _internal_action();
}
inline void PipeConfig::unsafe_arena_set_allocated_action(
    ::flow_grpc::Action* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.PipeConfig.action)
}
inline ::flow_grpc::Action* PipeConfig::release_action() {
  
  ::flow_grpc::Action* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::Action* PipeConfig::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:flow_grpc.PipeConfig.action)
  
  ::flow_grpc::Action* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::flow_grpc::Action* PipeConfig::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::Action>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::flow_grpc::Action* PipeConfig::mutable_action() {
  ::flow_grpc::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:flow_grpc.PipeConfig.action)
  return _msg;
}
inline void PipeConfig::set_allocated_action(::flow_grpc::Action* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::Action>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.PipeConfig.action)
}

// uint32 nb_flows = 7;
inline void PipeConfig::clear_nb_flows() {
  nb_flows_ = 0u;
}
inline uint32_t PipeConfig::_internal_nb_flows() const {
  return nb_flows_;
}
inline uint32_t PipeConfig::nb_flows() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PipeConfig.nb_flows)
  return _internal_nb_flows();
}
inline void PipeConfig::_internal_set_nb_flows(uint32_t value) {
  
  nb_flows_ = value;
}
inline void PipeConfig::set_nb_flows(uint32_t value) {
  _internal_set_nb_flows(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PipeConfig.nb_flows)
}

// -------------------------------------------------------------------

// Match

// string match_rule = 1;
inline void Match::clear_match_rule() {
  match_rule_.ClearToEmpty();
}
inline const std::string& Match::match_rule() const {
  // @@protoc_insertion_point(field_get:flow_grpc.Match.match_rule)
  return _internal_match_rule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Match::set_match_rule(ArgT0&& arg0, ArgT... args) {
 
 match_rule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow_grpc.Match.match_rule)
}
inline std::string* Match::mutable_match_rule() {
  std::string* _s = _internal_mutable_match_rule();
  // @@protoc_insertion_point(field_mutable:flow_grpc.Match.match_rule)
  return _s;
}
inline const std::string& Match::_internal_match_rule() const {
  return match_rule_.Get();
}
inline void Match::_internal_set_match_rule(const std::string& value) {
  
  match_rule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Match::_internal_mutable_match_rule() {
  
  return match_rule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Match::release_match_rule() {
  // @@protoc_insertion_point(field_release:flow_grpc.Match.match_rule)
  return match_rule_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Match::set_allocated_match_rule(std::string* match_rule) {
  if (match_rule != nullptr) {
    
  } else {
    
  }
  match_rule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), match_rule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (match_rule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    match_rule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.Match.match_rule)
}

// -------------------------------------------------------------------

// Action

// string action_rule = 1;
inline void Action::clear_action_rule() {
  action_rule_.ClearToEmpty();
}
inline const std::string& Action::action_rule() const {
  // @@protoc_insertion_point(field_get:flow_grpc.Action.action_rule)
  return _internal_action_rule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Action::set_action_rule(ArgT0&& arg0, ArgT... args) {
 
 action_rule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow_grpc.Action.action_rule)
}
inline std::string* Action::mutable_action_rule() {
  std::string* _s = _internal_mutable_action_rule();
  // @@protoc_insertion_point(field_mutable:flow_grpc.Action.action_rule)
  return _s;
}
inline const std::string& Action::_internal_action_rule() const {
  return action_rule_.Get();
}
inline void Action::_internal_set_action_rule(const std::string& value) {
  
  action_rule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Action::_internal_mutable_action_rule() {
  
  return action_rule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Action::release_action_rule() {
  // @@protoc_insertion_point(field_release:flow_grpc.Action.action_rule)
  return action_rule_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Action::set_allocated_action_rule(std::string* action_rule) {
  if (action_rule != nullptr) {
    
  } else {
    
  }
  action_rule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action_rule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_rule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_rule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.Action.action_rule)
}

// -------------------------------------------------------------------

// FWD

// string fwd_rule = 1;
inline void FWD::clear_fwd_rule() {
  fwd_rule_.ClearToEmpty();
}
inline const std::string& FWD::fwd_rule() const {
  // @@protoc_insertion_point(field_get:flow_grpc.FWD.fwd_rule)
  return _internal_fwd_rule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FWD::set_fwd_rule(ArgT0&& arg0, ArgT... args) {
 
 fwd_rule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow_grpc.FWD.fwd_rule)
}
inline std::string* FWD::mutable_fwd_rule() {
  std::string* _s = _internal_mutable_fwd_rule();
  // @@protoc_insertion_point(field_mutable:flow_grpc.FWD.fwd_rule)
  return _s;
}
inline const std::string& FWD::_internal_fwd_rule() const {
  return fwd_rule_.Get();
}
inline void FWD::_internal_set_fwd_rule(const std::string& value) {
  
  fwd_rule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FWD::_internal_mutable_fwd_rule() {
  
  return fwd_rule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FWD::release_fwd_rule() {
  // @@protoc_insertion_point(field_release:flow_grpc.FWD.fwd_rule)
  return fwd_rule_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FWD::set_allocated_fwd_rule(std::string* fwd_rule) {
  if (fwd_rule != nullptr) {
    
  } else {
    
  }
  fwd_rule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fwd_rule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fwd_rule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fwd_rule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.FWD.fwd_rule)
}

// -------------------------------------------------------------------

// CreatePipeRequest

// .flow_grpc.PipeConfig pipe_config = 1;
inline bool CreatePipeRequest::_internal_has_pipe_config() const {
  return this != internal_default_instance() && pipe_config_ != nullptr;
}
inline bool CreatePipeRequest::has_pipe_config() const {
  return _internal_has_pipe_config();
}
inline void CreatePipeRequest::clear_pipe_config() {
  if (GetArenaForAllocation() == nullptr && pipe_config_ != nullptr) {
    delete pipe_config_;
  }
  pipe_config_ = nullptr;
}
inline const ::flow_grpc::PipeConfig& CreatePipeRequest::_internal_pipe_config() const {
  const ::flow_grpc::PipeConfig* p = pipe_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::PipeConfig&>(
      ::flow_grpc::_PipeConfig_default_instance_);
}
inline const ::flow_grpc::PipeConfig& CreatePipeRequest::pipe_config() const {
  // @@protoc_insertion_point(field_get:flow_grpc.CreatePipeRequest.pipe_config)
  return _internal_pipe_config();
}
inline void CreatePipeRequest::unsafe_arena_set_allocated_pipe_config(
    ::flow_grpc::PipeConfig* pipe_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(pipe_config_);
  }
  pipe_config_ = pipe_config;
  if (pipe_config) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.CreatePipeRequest.pipe_config)
}
inline ::flow_grpc::PipeConfig* CreatePipeRequest::release_pipe_config() {
  
  ::flow_grpc::PipeConfig* temp = pipe_config_;
  pipe_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::PipeConfig* CreatePipeRequest::unsafe_arena_release_pipe_config() {
  // @@protoc_insertion_point(field_release:flow_grpc.CreatePipeRequest.pipe_config)
  
  ::flow_grpc::PipeConfig* temp = pipe_config_;
  pipe_config_ = nullptr;
  return temp;
}
inline ::flow_grpc::PipeConfig* CreatePipeRequest::_internal_mutable_pipe_config() {
  
  if (pipe_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::PipeConfig>(GetArenaForAllocation());
    pipe_config_ = p;
  }
  return pipe_config_;
}
inline ::flow_grpc::PipeConfig* CreatePipeRequest::mutable_pipe_config() {
  ::flow_grpc::PipeConfig* _msg = _internal_mutable_pipe_config();
  // @@protoc_insertion_point(field_mutable:flow_grpc.CreatePipeRequest.pipe_config)
  return _msg;
}
inline void CreatePipeRequest::set_allocated_pipe_config(::flow_grpc::PipeConfig* pipe_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete pipe_config_;
  }
  if (pipe_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::PipeConfig>::GetOwningArena(pipe_config);
    if (message_arena != submessage_arena) {
      pipe_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pipe_config, submessage_arena);
    }
    
  } else {
    
  }
  pipe_config_ = pipe_config;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.CreatePipeRequest.pipe_config)
}

// .flow_grpc.FWD fwd = 2;
inline bool CreatePipeRequest::_internal_has_fwd() const {
  return this != internal_default_instance() && fwd_ != nullptr;
}
inline bool CreatePipeRequest::has_fwd() const {
  return _internal_has_fwd();
}
inline void CreatePipeRequest::clear_fwd() {
  if (GetArenaForAllocation() == nullptr && fwd_ != nullptr) {
    delete fwd_;
  }
  fwd_ = nullptr;
}
inline const ::flow_grpc::FWD& CreatePipeRequest::_internal_fwd() const {
  const ::flow_grpc::FWD* p = fwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::FWD&>(
      ::flow_grpc::_FWD_default_instance_);
}
inline const ::flow_grpc::FWD& CreatePipeRequest::fwd() const {
  // @@protoc_insertion_point(field_get:flow_grpc.CreatePipeRequest.fwd)
  return _internal_fwd();
}
inline void CreatePipeRequest::unsafe_arena_set_allocated_fwd(
    ::flow_grpc::FWD* fwd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fwd_);
  }
  fwd_ = fwd;
  if (fwd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.CreatePipeRequest.fwd)
}
inline ::flow_grpc::FWD* CreatePipeRequest::release_fwd() {
  
  ::flow_grpc::FWD* temp = fwd_;
  fwd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::FWD* CreatePipeRequest::unsafe_arena_release_fwd() {
  // @@protoc_insertion_point(field_release:flow_grpc.CreatePipeRequest.fwd)
  
  ::flow_grpc::FWD* temp = fwd_;
  fwd_ = nullptr;
  return temp;
}
inline ::flow_grpc::FWD* CreatePipeRequest::_internal_mutable_fwd() {
  
  if (fwd_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::FWD>(GetArenaForAllocation());
    fwd_ = p;
  }
  return fwd_;
}
inline ::flow_grpc::FWD* CreatePipeRequest::mutable_fwd() {
  ::flow_grpc::FWD* _msg = _internal_mutable_fwd();
  // @@protoc_insertion_point(field_mutable:flow_grpc.CreatePipeRequest.fwd)
  return _msg;
}
inline void CreatePipeRequest::set_allocated_fwd(::flow_grpc::FWD* fwd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fwd_;
  }
  if (fwd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::FWD>::GetOwningArena(fwd);
    if (message_arena != submessage_arena) {
      fwd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fwd, submessage_arena);
    }
    
  } else {
    
  }
  fwd_ = fwd;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.CreatePipeRequest.fwd)
}

// .flow_grpc.FWD fwd_miss = 3;
inline bool CreatePipeRequest::_internal_has_fwd_miss() const {
  return this != internal_default_instance() && fwd_miss_ != nullptr;
}
inline bool CreatePipeRequest::has_fwd_miss() const {
  return _internal_has_fwd_miss();
}
inline void CreatePipeRequest::clear_fwd_miss() {
  if (GetArenaForAllocation() == nullptr && fwd_miss_ != nullptr) {
    delete fwd_miss_;
  }
  fwd_miss_ = nullptr;
}
inline const ::flow_grpc::FWD& CreatePipeRequest::_internal_fwd_miss() const {
  const ::flow_grpc::FWD* p = fwd_miss_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::FWD&>(
      ::flow_grpc::_FWD_default_instance_);
}
inline const ::flow_grpc::FWD& CreatePipeRequest::fwd_miss() const {
  // @@protoc_insertion_point(field_get:flow_grpc.CreatePipeRequest.fwd_miss)
  return _internal_fwd_miss();
}
inline void CreatePipeRequest::unsafe_arena_set_allocated_fwd_miss(
    ::flow_grpc::FWD* fwd_miss) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fwd_miss_);
  }
  fwd_miss_ = fwd_miss;
  if (fwd_miss) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.CreatePipeRequest.fwd_miss)
}
inline ::flow_grpc::FWD* CreatePipeRequest::release_fwd_miss() {
  
  ::flow_grpc::FWD* temp = fwd_miss_;
  fwd_miss_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::FWD* CreatePipeRequest::unsafe_arena_release_fwd_miss() {
  // @@protoc_insertion_point(field_release:flow_grpc.CreatePipeRequest.fwd_miss)
  
  ::flow_grpc::FWD* temp = fwd_miss_;
  fwd_miss_ = nullptr;
  return temp;
}
inline ::flow_grpc::FWD* CreatePipeRequest::_internal_mutable_fwd_miss() {
  
  if (fwd_miss_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::FWD>(GetArenaForAllocation());
    fwd_miss_ = p;
  }
  return fwd_miss_;
}
inline ::flow_grpc::FWD* CreatePipeRequest::mutable_fwd_miss() {
  ::flow_grpc::FWD* _msg = _internal_mutable_fwd_miss();
  // @@protoc_insertion_point(field_mutable:flow_grpc.CreatePipeRequest.fwd_miss)
  return _msg;
}
inline void CreatePipeRequest::set_allocated_fwd_miss(::flow_grpc::FWD* fwd_miss) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fwd_miss_;
  }
  if (fwd_miss) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::FWD>::GetOwningArena(fwd_miss);
    if (message_arena != submessage_arena) {
      fwd_miss = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fwd_miss, submessage_arena);
    }
    
  } else {
    
  }
  fwd_miss_ = fwd_miss;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.CreatePipeRequest.fwd_miss)
}

// -------------------------------------------------------------------

// AddEntryRequest

// uint32 pipe_queue = 1;
inline void AddEntryRequest::clear_pipe_queue() {
  pipe_queue_ = 0u;
}
inline uint32_t AddEntryRequest::_internal_pipe_queue() const {
  return pipe_queue_;
}
inline uint32_t AddEntryRequest::pipe_queue() const {
  // @@protoc_insertion_point(field_get:flow_grpc.AddEntryRequest.pipe_queue)
  return _internal_pipe_queue();
}
inline void AddEntryRequest::_internal_set_pipe_queue(uint32_t value) {
  
  pipe_queue_ = value;
}
inline void AddEntryRequest::set_pipe_queue(uint32_t value) {
  _internal_set_pipe_queue(value);
  // @@protoc_insertion_point(field_set:flow_grpc.AddEntryRequest.pipe_queue)
}

// uint64 pipe_id = 2;
inline void AddEntryRequest::clear_pipe_id() {
  pipe_id_ = uint64_t{0u};
}
inline uint64_t AddEntryRequest::_internal_pipe_id() const {
  return pipe_id_;
}
inline uint64_t AddEntryRequest::pipe_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.AddEntryRequest.pipe_id)
  return _internal_pipe_id();
}
inline void AddEntryRequest::_internal_set_pipe_id(uint64_t value) {
  
  pipe_id_ = value;
}
inline void AddEntryRequest::set_pipe_id(uint64_t value) {
  _internal_set_pipe_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.AddEntryRequest.pipe_id)
}

// .flow_grpc.Match match = 3;
inline bool AddEntryRequest::_internal_has_match() const {
  return this != internal_default_instance() && match_ != nullptr;
}
inline bool AddEntryRequest::has_match() const {
  return _internal_has_match();
}
inline void AddEntryRequest::clear_match() {
  if (GetArenaForAllocation() == nullptr && match_ != nullptr) {
    delete match_;
  }
  match_ = nullptr;
}
inline const ::flow_grpc::Match& AddEntryRequest::_internal_match() const {
  const ::flow_grpc::Match* p = match_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::Match&>(
      ::flow_grpc::_Match_default_instance_);
}
inline const ::flow_grpc::Match& AddEntryRequest::match() const {
  // @@protoc_insertion_point(field_get:flow_grpc.AddEntryRequest.match)
  return _internal_match();
}
inline void AddEntryRequest::unsafe_arena_set_allocated_match(
    ::flow_grpc::Match* match) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(match_);
  }
  match_ = match;
  if (match) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.AddEntryRequest.match)
}
inline ::flow_grpc::Match* AddEntryRequest::release_match() {
  
  ::flow_grpc::Match* temp = match_;
  match_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::Match* AddEntryRequest::unsafe_arena_release_match() {
  // @@protoc_insertion_point(field_release:flow_grpc.AddEntryRequest.match)
  
  ::flow_grpc::Match* temp = match_;
  match_ = nullptr;
  return temp;
}
inline ::flow_grpc::Match* AddEntryRequest::_internal_mutable_match() {
  
  if (match_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::Match>(GetArenaForAllocation());
    match_ = p;
  }
  return match_;
}
inline ::flow_grpc::Match* AddEntryRequest::mutable_match() {
  ::flow_grpc::Match* _msg = _internal_mutable_match();
  // @@protoc_insertion_point(field_mutable:flow_grpc.AddEntryRequest.match)
  return _msg;
}
inline void AddEntryRequest::set_allocated_match(::flow_grpc::Match* match) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete match_;
  }
  if (match) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::Match>::GetOwningArena(match);
    if (message_arena != submessage_arena) {
      match = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, match, submessage_arena);
    }
    
  } else {
    
  }
  match_ = match;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.AddEntryRequest.match)
}

// .flow_grpc.Action action = 4;
inline bool AddEntryRequest::_internal_has_action() const {
  return this != internal_default_instance() && action_ != nullptr;
}
inline bool AddEntryRequest::has_action() const {
  return _internal_has_action();
}
inline void AddEntryRequest::clear_action() {
  if (GetArenaForAllocation() == nullptr && action_ != nullptr) {
    delete action_;
  }
  action_ = nullptr;
}
inline const ::flow_grpc::Action& AddEntryRequest::_internal_action() const {
  const ::flow_grpc::Action* p = action_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::Action&>(
      ::flow_grpc::_Action_default_instance_);
}
inline const ::flow_grpc::Action& AddEntryRequest::action() const {
  // @@protoc_insertion_point(field_get:flow_grpc.AddEntryRequest.action)
  return _internal_action();
}
inline void AddEntryRequest::unsafe_arena_set_allocated_action(
    ::flow_grpc::Action* action) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(action_);
  }
  action_ = action;
  if (action) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.AddEntryRequest.action)
}
inline ::flow_grpc::Action* AddEntryRequest::release_action() {
  
  ::flow_grpc::Action* temp = action_;
  action_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::Action* AddEntryRequest::unsafe_arena_release_action() {
  // @@protoc_insertion_point(field_release:flow_grpc.AddEntryRequest.action)
  
  ::flow_grpc::Action* temp = action_;
  action_ = nullptr;
  return temp;
}
inline ::flow_grpc::Action* AddEntryRequest::_internal_mutable_action() {
  
  if (action_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::Action>(GetArenaForAllocation());
    action_ = p;
  }
  return action_;
}
inline ::flow_grpc::Action* AddEntryRequest::mutable_action() {
  ::flow_grpc::Action* _msg = _internal_mutable_action();
  // @@protoc_insertion_point(field_mutable:flow_grpc.AddEntryRequest.action)
  return _msg;
}
inline void AddEntryRequest::set_allocated_action(::flow_grpc::Action* action) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete action_;
  }
  if (action) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::Action>::GetOwningArena(action);
    if (message_arena != submessage_arena) {
      action = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, action, submessage_arena);
    }
    
  } else {
    
  }
  action_ = action;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.AddEntryRequest.action)
}

// .flow_grpc.FWD fwd = 5;
inline bool AddEntryRequest::_internal_has_fwd() const {
  return this != internal_default_instance() && fwd_ != nullptr;
}
inline bool AddEntryRequest::has_fwd() const {
  return _internal_has_fwd();
}
inline void AddEntryRequest::clear_fwd() {
  if (GetArenaForAllocation() == nullptr && fwd_ != nullptr) {
    delete fwd_;
  }
  fwd_ = nullptr;
}
inline const ::flow_grpc::FWD& AddEntryRequest::_internal_fwd() const {
  const ::flow_grpc::FWD* p = fwd_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow_grpc::FWD&>(
      ::flow_grpc::_FWD_default_instance_);
}
inline const ::flow_grpc::FWD& AddEntryRequest::fwd() const {
  // @@protoc_insertion_point(field_get:flow_grpc.AddEntryRequest.fwd)
  return _internal_fwd();
}
inline void AddEntryRequest::unsafe_arena_set_allocated_fwd(
    ::flow_grpc::FWD* fwd) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fwd_);
  }
  fwd_ = fwd;
  if (fwd) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow_grpc.AddEntryRequest.fwd)
}
inline ::flow_grpc::FWD* AddEntryRequest::release_fwd() {
  
  ::flow_grpc::FWD* temp = fwd_;
  fwd_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow_grpc::FWD* AddEntryRequest::unsafe_arena_release_fwd() {
  // @@protoc_insertion_point(field_release:flow_grpc.AddEntryRequest.fwd)
  
  ::flow_grpc::FWD* temp = fwd_;
  fwd_ = nullptr;
  return temp;
}
inline ::flow_grpc::FWD* AddEntryRequest::_internal_mutable_fwd() {
  
  if (fwd_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow_grpc::FWD>(GetArenaForAllocation());
    fwd_ = p;
  }
  return fwd_;
}
inline ::flow_grpc::FWD* AddEntryRequest::mutable_fwd() {
  ::flow_grpc::FWD* _msg = _internal_mutable_fwd();
  // @@protoc_insertion_point(field_mutable:flow_grpc.AddEntryRequest.fwd)
  return _msg;
}
inline void AddEntryRequest::set_allocated_fwd(::flow_grpc::FWD* fwd) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete fwd_;
  }
  if (fwd) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow_grpc::FWD>::GetOwningArena(fwd);
    if (message_arena != submessage_arena) {
      fwd = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fwd, submessage_arena);
    }
    
  } else {
    
  }
  fwd_ = fwd;
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.AddEntryRequest.fwd)
}

// uint32 flags = 6;
inline void AddEntryRequest::clear_flags() {
  flags_ = 0u;
}
inline uint32_t AddEntryRequest::_internal_flags() const {
  return flags_;
}
inline uint32_t AddEntryRequest::flags() const {
  // @@protoc_insertion_point(field_get:flow_grpc.AddEntryRequest.flags)
  return _internal_flags();
}
inline void AddEntryRequest::_internal_set_flags(uint32_t value) {
  
  flags_ = value;
}
inline void AddEntryRequest::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:flow_grpc.AddEntryRequest.flags)
}

// -------------------------------------------------------------------

// PortDumpRequest

// uint32 port_id = 1;
inline void PortDumpRequest::clear_port_id() {
  port_id_ = 0u;
}
inline uint32_t PortDumpRequest::_internal_port_id() const {
  return port_id_;
}
inline uint32_t PortDumpRequest::port_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PortDumpRequest.port_id)
  return _internal_port_id();
}
inline void PortDumpRequest::_internal_set_port_id(uint32_t value) {
  
  port_id_ = value;
}
inline void PortDumpRequest::set_port_id(uint32_t value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PortDumpRequest.port_id)
}

// string result = 2;
inline void PortDumpRequest::clear_result() {
  result_.ClearToEmpty();
}
inline const std::string& PortDumpRequest::result() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PortDumpRequest.result)
  return _internal_result();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PortDumpRequest::set_result(ArgT0&& arg0, ArgT... args) {
 
 result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow_grpc.PortDumpRequest.result)
}
inline std::string* PortDumpRequest::mutable_result() {
  std::string* _s = _internal_mutable_result();
  // @@protoc_insertion_point(field_mutable:flow_grpc.PortDumpRequest.result)
  return _s;
}
inline const std::string& PortDumpRequest::_internal_result() const {
  return result_.Get();
}
inline void PortDumpRequest::_internal_set_result(const std::string& value) {
  
  result_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* PortDumpRequest::_internal_mutable_result() {
  
  return result_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* PortDumpRequest::release_result() {
  // @@protoc_insertion_point(field_release:flow_grpc.PortDumpRequest.result)
  return result_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void PortDumpRequest::set_allocated_result(std::string* result) {
  if (result != nullptr) {
    
  } else {
    
  }
  result_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), result,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (result_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    result_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:flow_grpc.PortDumpRequest.result)
}

// -------------------------------------------------------------------

// QueryRequest

// uint64 entry_id = 1;
inline void QueryRequest::clear_entry_id() {
  entry_id_ = uint64_t{0u};
}
inline uint64_t QueryRequest::_internal_entry_id() const {
  return entry_id_;
}
inline uint64_t QueryRequest::entry_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.QueryRequest.entry_id)
  return _internal_entry_id();
}
inline void QueryRequest::_internal_set_entry_id(uint64_t value) {
  
  entry_id_ = value;
}
inline void QueryRequest::set_entry_id(uint64_t value) {
  _internal_set_entry_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.QueryRequest.entry_id)
}

// uint64 total_bytes = 2;
inline void QueryRequest::clear_total_bytes() {
  total_bytes_ = uint64_t{0u};
}
inline uint64_t QueryRequest::_internal_total_bytes() const {
  return total_bytes_;
}
inline uint64_t QueryRequest::total_bytes() const {
  // @@protoc_insertion_point(field_get:flow_grpc.QueryRequest.total_bytes)
  return _internal_total_bytes();
}
inline void QueryRequest::_internal_set_total_bytes(uint64_t value) {
  
  total_bytes_ = value;
}
inline void QueryRequest::set_total_bytes(uint64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:flow_grpc.QueryRequest.total_bytes)
}

// uint64 total_pkts = 3;
inline void QueryRequest::clear_total_pkts() {
  total_pkts_ = uint64_t{0u};
}
inline uint64_t QueryRequest::_internal_total_pkts() const {
  return total_pkts_;
}
inline uint64_t QueryRequest::total_pkts() const {
  // @@protoc_insertion_point(field_get:flow_grpc.QueryRequest.total_pkts)
  return _internal_total_pkts();
}
inline void QueryRequest::_internal_set_total_pkts(uint64_t value) {
  
  total_pkts_ = value;
}
inline void QueryRequest::set_total_pkts(uint64_t value) {
  _internal_set_total_pkts(value);
  // @@protoc_insertion_point(field_set:flow_grpc.QueryRequest.total_pkts)
}

// -------------------------------------------------------------------

// PortFlushRequest

// uint32 port_id = 1;
inline void PortFlushRequest::clear_port_id() {
  port_id_ = 0u;
}
inline uint32_t PortFlushRequest::_internal_port_id() const {
  return port_id_;
}
inline uint32_t PortFlushRequest::port_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.PortFlushRequest.port_id)
  return _internal_port_id();
}
inline void PortFlushRequest::_internal_set_port_id(uint32_t value) {
  
  port_id_ = value;
}
inline void PortFlushRequest::set_port_id(uint32_t value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.PortFlushRequest.port_id)
}

// -------------------------------------------------------------------

// RmEntryRequest

// uint32 pipe_queue = 1;
inline void RmEntryRequest::clear_pipe_queue() {
  pipe_queue_ = 0u;
}
inline uint32_t RmEntryRequest::_internal_pipe_queue() const {
  return pipe_queue_;
}
inline uint32_t RmEntryRequest::pipe_queue() const {
  // @@protoc_insertion_point(field_get:flow_grpc.RmEntryRequest.pipe_queue)
  return _internal_pipe_queue();
}
inline void RmEntryRequest::_internal_set_pipe_queue(uint32_t value) {
  
  pipe_queue_ = value;
}
inline void RmEntryRequest::set_pipe_queue(uint32_t value) {
  _internal_set_pipe_queue(value);
  // @@protoc_insertion_point(field_set:flow_grpc.RmEntryRequest.pipe_queue)
}

// uint64 entry_id = 2;
inline void RmEntryRequest::clear_entry_id() {
  entry_id_ = uint64_t{0u};
}
inline uint64_t RmEntryRequest::_internal_entry_id() const {
  return entry_id_;
}
inline uint64_t RmEntryRequest::entry_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.RmEntryRequest.entry_id)
  return _internal_entry_id();
}
inline void RmEntryRequest::_internal_set_entry_id(uint64_t value) {
  
  entry_id_ = value;
}
inline void RmEntryRequest::set_entry_id(uint64_t value) {
  _internal_set_entry_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.RmEntryRequest.entry_id)
}

// -------------------------------------------------------------------

// DestroyPipeRequest

// uint32 port_id = 1;
inline void DestroyPipeRequest::clear_port_id() {
  port_id_ = 0u;
}
inline uint32_t DestroyPipeRequest::_internal_port_id() const {
  return port_id_;
}
inline uint32_t DestroyPipeRequest::port_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.DestroyPipeRequest.port_id)
  return _internal_port_id();
}
inline void DestroyPipeRequest::_internal_set_port_id(uint32_t value) {
  
  port_id_ = value;
}
inline void DestroyPipeRequest::set_port_id(uint32_t value) {
  _internal_set_port_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.DestroyPipeRequest.port_id)
}

// uint64 pipe_id = 2;
inline void DestroyPipeRequest::clear_pipe_id() {
  pipe_id_ = uint64_t{0u};
}
inline uint64_t DestroyPipeRequest::_internal_pipe_id() const {
  return pipe_id_;
}
inline uint64_t DestroyPipeRequest::pipe_id() const {
  // @@protoc_insertion_point(field_get:flow_grpc.DestroyPipeRequest.pipe_id)
  return _internal_pipe_id();
}
inline void DestroyPipeRequest::_internal_set_pipe_id(uint64_t value) {
  
  pipe_id_ = value;
}
inline void DestroyPipeRequest::set_pipe_id(uint64_t value) {
  _internal_set_pipe_id(value);
  // @@protoc_insertion_point(field_set:flow_grpc.DestroyPipeRequest.pipe_id)
}

// -------------------------------------------------------------------

// EnvDestroyRequest

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace flow_grpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flow_5fgrpc_2eproto
