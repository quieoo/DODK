// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: flow_grpc.proto
#ifndef GRPC_flow_5fgrpc_2eproto__INCLUDED
#define GRPC_flow_5fgrpc_2eproto__INCLUDED

#include "flow_grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace flow_grpc {

class FlowGRPC final {
 public:
  static constexpr char const* service_full_name() {
    return "flow_grpc.FlowGRPC";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status EnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncEnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncEnvInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncEnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncEnvInitializeRaw(context, request, cq));
    }
    virtual ::grpc::Status GRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncGRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncGRPCInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncGRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncGRPCInitializeRaw(context, request, cq));
    }
    virtual ::grpc::Status PortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncPortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncPortStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncPortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncPortStartRaw(context, request, cq));
    }
    virtual ::grpc::Status PortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncPortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncPortPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncPortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncPortPairRaw(context, request, cq));
    }
    virtual ::grpc::Status CreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncCreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncCreatePipeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncCreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncCreatePipeRaw(context, request, cq));
    }
    virtual ::grpc::Status AddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncAddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncAddEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncAddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncAddEntryRaw(context, request, cq));
    }
    virtual ::grpc::Status PortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncPortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncPortPipesDumpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncPortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncPortPipesDumpRaw(context, request, cq));
    }
    virtual ::grpc::Status Query(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncQuery(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncQuery(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncQueryRaw(context, request, cq));
    }
    virtual ::grpc::Status FlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncFlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncFlushPortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncFlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncFlushPortRaw(context, request, cq));
    }
    virtual ::grpc::Status RmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncRmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncRmEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncRmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncRmEntryRaw(context, request, cq));
    }
    virtual ::grpc::Status DestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncDestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncDestroyPipeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncDestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncDestroyPipeRaw(context, request, cq));
    }
    virtual ::grpc::Status EnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncEnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncEnvDestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncEnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncEnvDestroyRaw(context, request, cq));
    }
    virtual ::grpc::Status DestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::flow_grpc::Response* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> AsyncDestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(AsyncDestroyPortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>> PrepareAsyncDestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>>(PrepareAsyncDestroyPortRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void EnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void AddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void PortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Query(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Query(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void FlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void FlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void RmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void RmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncEnvInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncEnvInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncGRPCInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncGRPCInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncPortStartRaw(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncPortStartRaw(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncPortPairRaw(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncPortPairRaw(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncCreatePipeRaw(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncCreatePipeRaw(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncAddEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncAddEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncPortPipesDumpRaw(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncPortPipesDumpRaw(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncQueryRaw(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncQueryRaw(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncFlushPortRaw(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncFlushPortRaw(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncRmEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncRmEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncDestroyPipeRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncDestroyPipeRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncEnvDestroyRaw(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncEnvDestroyRaw(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* AsyncDestroyPortRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow_grpc::Response>* PrepareAsyncDestroyPortRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status EnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncEnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncEnvInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncEnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncEnvInitializeRaw(context, request, cq));
    }
    ::grpc::Status GRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncGRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncGRPCInitializeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncGRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncGRPCInitializeRaw(context, request, cq));
    }
    ::grpc::Status PortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncPortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncPortStartRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncPortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncPortStartRaw(context, request, cq));
    }
    ::grpc::Status PortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncPortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncPortPairRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncPortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncPortPairRaw(context, request, cq));
    }
    ::grpc::Status CreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncCreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncCreatePipeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncCreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncCreatePipeRaw(context, request, cq));
    }
    ::grpc::Status AddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncAddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncAddEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncAddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncAddEntryRaw(context, request, cq));
    }
    ::grpc::Status PortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncPortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncPortPipesDumpRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncPortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncPortPipesDumpRaw(context, request, cq));
    }
    ::grpc::Status Query(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncQuery(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncQueryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncQuery(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncQueryRaw(context, request, cq));
    }
    ::grpc::Status FlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncFlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncFlushPortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncFlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncFlushPortRaw(context, request, cq));
    }
    ::grpc::Status RmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncRmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncRmEntryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncRmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncRmEntryRaw(context, request, cq));
    }
    ::grpc::Status DestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncDestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncDestroyPipeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncDestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncDestroyPipeRaw(context, request, cq));
    }
    ::grpc::Status EnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncEnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncEnvDestroyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncEnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncEnvDestroyRaw(context, request, cq));
    }
    ::grpc::Status DestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::flow_grpc::Response* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> AsyncDestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(AsyncDestroyPortRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>> PrepareAsyncDestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>>(PrepareAsyncDestroyPortRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void EnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void EnvInitialize(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void GRPCInitialize(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void PortStart(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void PortPair(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void CreatePipe(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void AddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void AddEntry(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void PortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void PortPipesDump(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Query(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void Query(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void FlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void FlushPort(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void RmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void RmEntry(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void DestroyPipe(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void EnvDestroy(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest* request, ::flow_grpc::Response* response, std::function<void(::grpc::Status)>) override;
      void DestroyPort(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest* request, ::flow_grpc::Response* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncEnvInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncEnvInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::DPDKConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncGRPCInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncGRPCInitializeRaw(::grpc::ClientContext* context, const ::flow_grpc::GRPCConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncPortStartRaw(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncPortStartRaw(::grpc::ClientContext* context, const ::flow_grpc::FlowPortConfig& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncPortPairRaw(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncPortPairRaw(::grpc::ClientContext* context, const ::flow_grpc::PortPairRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncCreatePipeRaw(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncCreatePipeRaw(::grpc::ClientContext* context, const ::flow_grpc::CreatePipeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncAddEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncAddEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::AddEntryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncPortPipesDumpRaw(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncPortPipesDumpRaw(::grpc::ClientContext* context, const ::flow_grpc::PortDumpRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncQueryRaw(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncQueryRaw(::grpc::ClientContext* context, const ::flow_grpc::QueryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncFlushPortRaw(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncFlushPortRaw(::grpc::ClientContext* context, const ::flow_grpc::PortFlushRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncRmEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncRmEntryRaw(::grpc::ClientContext* context, const ::flow_grpc::RmEntryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncDestroyPipeRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncDestroyPipeRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPipeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncEnvDestroyRaw(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncEnvDestroyRaw(::grpc::ClientContext* context, const ::flow_grpc::EnvDestroyRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* AsyncDestroyPortRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow_grpc::Response>* PrepareAsyncDestroyPortRaw(::grpc::ClientContext* context, const ::flow_grpc::DestroyPortRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_EnvInitialize_;
    const ::grpc::internal::RpcMethod rpcmethod_GRPCInitialize_;
    const ::grpc::internal::RpcMethod rpcmethod_PortStart_;
    const ::grpc::internal::RpcMethod rpcmethod_PortPair_;
    const ::grpc::internal::RpcMethod rpcmethod_CreatePipe_;
    const ::grpc::internal::RpcMethod rpcmethod_AddEntry_;
    const ::grpc::internal::RpcMethod rpcmethod_PortPipesDump_;
    const ::grpc::internal::RpcMethod rpcmethod_Query_;
    const ::grpc::internal::RpcMethod rpcmethod_FlushPort_;
    const ::grpc::internal::RpcMethod rpcmethod_RmEntry_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyPipe_;
    const ::grpc::internal::RpcMethod rpcmethod_EnvDestroy_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyPort_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status EnvInitialize(::grpc::ServerContext* context, const ::flow_grpc::DPDKConfig* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status GRPCInitialize(::grpc::ServerContext* context, const ::flow_grpc::GRPCConfig* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status PortStart(::grpc::ServerContext* context, const ::flow_grpc::FlowPortConfig* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status PortPair(::grpc::ServerContext* context, const ::flow_grpc::PortPairRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status CreatePipe(::grpc::ServerContext* context, const ::flow_grpc::CreatePipeRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status AddEntry(::grpc::ServerContext* context, const ::flow_grpc::AddEntryRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status PortPipesDump(::grpc::ServerContext* context, const ::flow_grpc::PortDumpRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status Query(::grpc::ServerContext* context, const ::flow_grpc::QueryRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status FlushPort(::grpc::ServerContext* context, const ::flow_grpc::PortFlushRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status RmEntry(::grpc::ServerContext* context, const ::flow_grpc::RmEntryRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status DestroyPipe(::grpc::ServerContext* context, const ::flow_grpc::DestroyPipeRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status EnvDestroy(::grpc::ServerContext* context, const ::flow_grpc::EnvDestroyRequest* request, ::flow_grpc::Response* response);
    virtual ::grpc::Status DestroyPort(::grpc::ServerContext* context, const ::flow_grpc::DestroyPortRequest* request, ::flow_grpc::Response* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_EnvInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnvInitialize() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_EnvInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnvInitialize(::grpc::ServerContext* context, ::flow_grpc::DPDKConfig* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GRPCInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GRPCInitialize() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GRPCInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GRPCInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGRPCInitialize(::grpc::ServerContext* context, ::flow_grpc::GRPCConfig* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PortStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PortStart() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_PortStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortStart(::grpc::ServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortStart(::grpc::ServerContext* context, ::flow_grpc::FlowPortConfig* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PortPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PortPair() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PortPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPair(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortPair(::grpc::ServerContext* context, ::flow_grpc::PortPairRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreatePipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreatePipe() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_CreatePipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreatePipe(::grpc::ServerContext* context, ::flow_grpc::CreatePipeRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AddEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AddEntry() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_AddEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddEntry(::grpc::ServerContext* context, ::flow_grpc::AddEntryRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PortPipesDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PortPipesDump() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PortPipesDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPipesDump(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortPipesDump(::grpc::ServerContext* context, ::flow_grpc::PortDumpRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Query : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Query() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_Query() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Query(::grpc::ServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQuery(::grpc::ServerContext* context, ::flow_grpc::QueryRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_FlushPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_FlushPort() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_FlushPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlushPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFlushPort(::grpc::ServerContext* context, ::flow_grpc::PortFlushRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RmEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RmEntry() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_RmEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RmEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRmEntry(::grpc::ServerContext* context, ::flow_grpc::RmEntryRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyPipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyPipe() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_DestroyPipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyPipe(::grpc::ServerContext* context, ::flow_grpc::DestroyPipeRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnvDestroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnvDestroy() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_EnvDestroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvDestroy(::grpc::ServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnvDestroy(::grpc::ServerContext* context, ::flow_grpc::EnvDestroyRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyPort() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyPort(::grpc::ServerContext* context, ::flow_grpc::DestroyPortRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow_grpc::Response>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_EnvInitialize<WithAsyncMethod_GRPCInitialize<WithAsyncMethod_PortStart<WithAsyncMethod_PortPair<WithAsyncMethod_CreatePipe<WithAsyncMethod_AddEntry<WithAsyncMethod_PortPipesDump<WithAsyncMethod_Query<WithAsyncMethod_FlushPort<WithAsyncMethod_RmEntry<WithAsyncMethod_DestroyPipe<WithAsyncMethod_EnvDestroy<WithAsyncMethod_DestroyPort<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_EnvInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnvInitialize() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::DPDKConfig, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::DPDKConfig* request, ::flow_grpc::Response* response) { return this->EnvInitialize(context, request, response); }));}
    void SetMessageAllocatorFor_EnvInitialize(
        ::grpc::MessageAllocator< ::flow_grpc::DPDKConfig, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::DPDKConfig, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnvInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnvInitialize(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GRPCInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GRPCInitialize() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::GRPCConfig, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::GRPCConfig* request, ::flow_grpc::Response* response) { return this->GRPCInitialize(context, request, response); }));}
    void SetMessageAllocatorFor_GRPCInitialize(
        ::grpc::MessageAllocator< ::flow_grpc::GRPCConfig, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::GRPCConfig, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GRPCInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GRPCInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GRPCInitialize(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PortStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PortStart() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::FlowPortConfig, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::FlowPortConfig* request, ::flow_grpc::Response* response) { return this->PortStart(context, request, response); }));}
    void SetMessageAllocatorFor_PortStart(
        ::grpc::MessageAllocator< ::flow_grpc::FlowPortConfig, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::FlowPortConfig, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PortStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortStart(::grpc::ServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortStart(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PortPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PortPair() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::PortPairRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::PortPairRequest* request, ::flow_grpc::Response* response) { return this->PortPair(context, request, response); }));}
    void SetMessageAllocatorFor_PortPair(
        ::grpc::MessageAllocator< ::flow_grpc::PortPairRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::PortPairRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PortPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPair(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortPair(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreatePipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreatePipe() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::CreatePipeRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::CreatePipeRequest* request, ::flow_grpc::Response* response) { return this->CreatePipe(context, request, response); }));}
    void SetMessageAllocatorFor_CreatePipe(
        ::grpc::MessageAllocator< ::flow_grpc::CreatePipeRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::CreatePipeRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreatePipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreatePipe(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_AddEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_AddEntry() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::AddEntryRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::AddEntryRequest* request, ::flow_grpc::Response* response) { return this->AddEntry(context, request, response); }));}
    void SetMessageAllocatorFor_AddEntry(
        ::grpc::MessageAllocator< ::flow_grpc::AddEntryRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::AddEntryRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_AddEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_PortPipesDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_PortPipesDump() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::PortDumpRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::PortDumpRequest* request, ::flow_grpc::Response* response) { return this->PortPipesDump(context, request, response); }));}
    void SetMessageAllocatorFor_PortPipesDump(
        ::grpc::MessageAllocator< ::flow_grpc::PortDumpRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::PortDumpRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_PortPipesDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPipesDump(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortPipesDump(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Query : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Query() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::QueryRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::QueryRequest* request, ::flow_grpc::Response* response) { return this->Query(context, request, response); }));}
    void SetMessageAllocatorFor_Query(
        ::grpc::MessageAllocator< ::flow_grpc::QueryRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::QueryRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Query() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Query(::grpc::ServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Query(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_FlushPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_FlushPort() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::PortFlushRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::PortFlushRequest* request, ::flow_grpc::Response* response) { return this->FlushPort(context, request, response); }));}
    void SetMessageAllocatorFor_FlushPort(
        ::grpc::MessageAllocator< ::flow_grpc::PortFlushRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::PortFlushRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_FlushPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlushPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FlushPort(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_RmEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_RmEntry() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::RmEntryRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::RmEntryRequest* request, ::flow_grpc::Response* response) { return this->RmEntry(context, request, response); }));}
    void SetMessageAllocatorFor_RmEntry(
        ::grpc::MessageAllocator< ::flow_grpc::RmEntryRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::RmEntryRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_RmEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RmEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RmEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyPipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyPipe() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::DestroyPipeRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::DestroyPipeRequest* request, ::flow_grpc::Response* response) { return this->DestroyPipe(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyPipe(
        ::grpc::MessageAllocator< ::flow_grpc::DestroyPipeRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::DestroyPipeRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyPipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyPipe(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnvDestroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnvDestroy() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::EnvDestroyRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::EnvDestroyRequest* request, ::flow_grpc::Response* response) { return this->EnvDestroy(context, request, response); }));}
    void SetMessageAllocatorFor_EnvDestroy(
        ::grpc::MessageAllocator< ::flow_grpc::EnvDestroyRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::EnvDestroyRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnvDestroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvDestroy(::grpc::ServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnvDestroy(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyPort() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::flow_grpc::DestroyPortRequest, ::flow_grpc::Response>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::flow_grpc::DestroyPortRequest* request, ::flow_grpc::Response* response) { return this->DestroyPort(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyPort(
        ::grpc::MessageAllocator< ::flow_grpc::DestroyPortRequest, ::flow_grpc::Response>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow_grpc::DestroyPortRequest, ::flow_grpc::Response>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyPort(
      ::grpc::CallbackServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_EnvInitialize<WithCallbackMethod_GRPCInitialize<WithCallbackMethod_PortStart<WithCallbackMethod_PortPair<WithCallbackMethod_CreatePipe<WithCallbackMethod_AddEntry<WithCallbackMethod_PortPipesDump<WithCallbackMethod_Query<WithCallbackMethod_FlushPort<WithCallbackMethod_RmEntry<WithCallbackMethod_DestroyPipe<WithCallbackMethod_EnvDestroy<WithCallbackMethod_DestroyPort<Service > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_EnvInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnvInitialize() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_EnvInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GRPCInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GRPCInitialize() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GRPCInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GRPCInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PortStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PortStart() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_PortStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortStart(::grpc::ServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PortPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PortPair() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PortPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPair(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreatePipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreatePipe() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_CreatePipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AddEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AddEntry() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_AddEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PortPipesDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PortPipesDump() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PortPipesDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPipesDump(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Query : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Query() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_Query() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Query(::grpc::ServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_FlushPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_FlushPort() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_FlushPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlushPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RmEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RmEntry() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_RmEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RmEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyPipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyPipe() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_DestroyPipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnvDestroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnvDestroy() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_EnvDestroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvDestroy(::grpc::ServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyPort() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnvInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnvInitialize() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_EnvInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnvInitialize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GRPCInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GRPCInitialize() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GRPCInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GRPCInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGRPCInitialize(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PortStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PortStart() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_PortStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortStart(::grpc::ServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortStart(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PortPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PortPair() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PortPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPair(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortPair(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreatePipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreatePipe() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_CreatePipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreatePipe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AddEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AddEntry() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_AddEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAddEntry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PortPipesDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PortPipesDump() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PortPipesDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPipesDump(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPortPipesDump(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Query : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Query() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_Query() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Query(::grpc::ServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestQuery(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_FlushPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_FlushPort() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_FlushPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlushPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFlushPort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RmEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RmEntry() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_RmEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RmEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRmEntry(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyPipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyPipe() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_DestroyPipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyPipe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnvDestroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnvDestroy() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_EnvDestroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvDestroy(::grpc::ServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnvDestroy(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyPort() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyPort(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnvInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnvInitialize() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnvInitialize(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnvInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnvInitialize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GRPCInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GRPCInitialize() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GRPCInitialize(context, request, response); }));
    }
    ~WithRawCallbackMethod_GRPCInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GRPCInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GRPCInitialize(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PortStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PortStart() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PortStart(context, request, response); }));
    }
    ~WithRawCallbackMethod_PortStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortStart(::grpc::ServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortStart(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PortPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PortPair() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PortPair(context, request, response); }));
    }
    ~WithRawCallbackMethod_PortPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPair(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortPair(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreatePipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreatePipe() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreatePipe(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreatePipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreatePipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreatePipe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_AddEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_AddEntry() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->AddEntry(context, request, response); }));
    }
    ~WithRawCallbackMethod_AddEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AddEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* AddEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_PortPipesDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_PortPipesDump() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PortPipesDump(context, request, response); }));
    }
    ~WithRawCallbackMethod_PortPipesDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PortPipesDump(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* PortPipesDump(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Query : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Query() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Query(context, request, response); }));
    }
    ~WithRawCallbackMethod_Query() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Query(::grpc::ServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Query(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_FlushPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_FlushPort() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->FlushPort(context, request, response); }));
    }
    ~WithRawCallbackMethod_FlushPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FlushPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* FlushPort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_RmEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_RmEntry() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->RmEntry(context, request, response); }));
    }
    ~WithRawCallbackMethod_RmEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RmEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* RmEntry(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyPipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyPipe() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyPipe(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyPipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyPipe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnvDestroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnvDestroy() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnvDestroy(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnvDestroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnvDestroy(::grpc::ServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnvDestroy(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyPort() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyPort(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyPort(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnvInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnvInitialize() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::DPDKConfig, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::DPDKConfig, ::flow_grpc::Response>* streamer) {
                       return this->StreamedEnvInitialize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnvInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnvInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::DPDKConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnvInitialize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::DPDKConfig,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GRPCInitialize : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GRPCInitialize() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::GRPCConfig, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::GRPCConfig, ::flow_grpc::Response>* streamer) {
                       return this->StreamedGRPCInitialize(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GRPCInitialize() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GRPCInitialize(::grpc::ServerContext* /*context*/, const ::flow_grpc::GRPCConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGRPCInitialize(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::GRPCConfig,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PortStart : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PortStart() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::FlowPortConfig, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::FlowPortConfig, ::flow_grpc::Response>* streamer) {
                       return this->StreamedPortStart(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PortStart() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PortStart(::grpc::ServerContext* /*context*/, const ::flow_grpc::FlowPortConfig* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPortStart(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::FlowPortConfig,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PortPair : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PortPair() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::PortPairRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::PortPairRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedPortPair(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PortPair() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PortPair(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortPairRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPortPair(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::PortPairRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreatePipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreatePipe() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::CreatePipeRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::CreatePipeRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedCreatePipe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreatePipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreatePipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::CreatePipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreatePipe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::CreatePipeRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AddEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AddEntry() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::AddEntryRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::AddEntryRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedAddEntry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_AddEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AddEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::AddEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAddEntry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::AddEntryRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PortPipesDump : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PortPipesDump() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::PortDumpRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::PortDumpRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedPortPipesDump(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PortPipesDump() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PortPipesDump(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortDumpRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPortPipesDump(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::PortDumpRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Query : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Query() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::QueryRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::QueryRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedQuery(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Query() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Query(::grpc::ServerContext* /*context*/, const ::flow_grpc::QueryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedQuery(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::QueryRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FlushPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_FlushPort() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::PortFlushRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::PortFlushRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedFlushPort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_FlushPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FlushPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::PortFlushRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFlushPort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::PortFlushRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_RmEntry : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_RmEntry() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::RmEntryRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::RmEntryRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedRmEntry(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_RmEntry() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status RmEntry(::grpc::ServerContext* /*context*/, const ::flow_grpc::RmEntryRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRmEntry(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::RmEntryRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyPipe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyPipe() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::DestroyPipeRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::DestroyPipeRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedDestroyPipe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyPipe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyPipe(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPipeRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyPipe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::DestroyPipeRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnvDestroy : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnvDestroy() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::EnvDestroyRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::EnvDestroyRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedEnvDestroy(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnvDestroy() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnvDestroy(::grpc::ServerContext* /*context*/, const ::flow_grpc::EnvDestroyRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnvDestroy(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::EnvDestroyRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyPort : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyPort() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow_grpc::DestroyPortRequest, ::flow_grpc::Response>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow_grpc::DestroyPortRequest, ::flow_grpc::Response>* streamer) {
                       return this->StreamedDestroyPort(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyPort() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyPort(::grpc::ServerContext* /*context*/, const ::flow_grpc::DestroyPortRequest* /*request*/, ::flow_grpc::Response* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyPort(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow_grpc::DestroyPortRequest,::flow_grpc::Response>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_EnvInitialize<WithStreamedUnaryMethod_GRPCInitialize<WithStreamedUnaryMethod_PortStart<WithStreamedUnaryMethod_PortPair<WithStreamedUnaryMethod_CreatePipe<WithStreamedUnaryMethod_AddEntry<WithStreamedUnaryMethod_PortPipesDump<WithStreamedUnaryMethod_Query<WithStreamedUnaryMethod_FlushPort<WithStreamedUnaryMethod_RmEntry<WithStreamedUnaryMethod_DestroyPipe<WithStreamedUnaryMethod_EnvDestroy<WithStreamedUnaryMethod_DestroyPort<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_EnvInitialize<WithStreamedUnaryMethod_GRPCInitialize<WithStreamedUnaryMethod_PortStart<WithStreamedUnaryMethod_PortPair<WithStreamedUnaryMethod_CreatePipe<WithStreamedUnaryMethod_AddEntry<WithStreamedUnaryMethod_PortPipesDump<WithStreamedUnaryMethod_Query<WithStreamedUnaryMethod_FlushPort<WithStreamedUnaryMethod_RmEntry<WithStreamedUnaryMethod_DestroyPipe<WithStreamedUnaryMethod_EnvDestroy<WithStreamedUnaryMethod_DestroyPort<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace flow_grpc


#endif  // GRPC_flow_5fgrpc_2eproto__INCLUDED
